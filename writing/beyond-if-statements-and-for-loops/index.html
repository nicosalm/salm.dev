<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="icon" type="image/svg+xml" href="/assets/favicon.svg">
        <style>:root{--bg-color:#fff;--text-color:#1a1a2a;--text-secondary:#666;--link-color:#0066dd;--border-color:#eee;--code-bg:#f5f5f5;--font-family-body:"charter",sans-serif;--font-family-code:"firacode","Fira Code","Consolas",monospace;--font-size-base:1rem;--font-size-small:.95rem;--line-height:1.6;--line-height-heading:1.2;--spacing-tiny:.25rem;--spacing-small:.5rem;--spacing-medium:1rem;--spacing-large:1.5rem;--spacing-xl:2rem;--transition:.3s ease;--border-standard:1px solid var(--border-color);--heading-margin:var(--spacing-large) 0 var(--spacing-medium)}@media (prefers-color-scheme:dark){:root{--bg-color:#0e0e14;--text-color:#e3e3e8;--text-secondary:#9090a0;--link-color:#6699ff;--border-color:#2a2a3e;--code-bg:#16161e}}*{box-sizing:border-box;margin:0;padding:0}body{font-family:var(--font-family-body);font-size:var(--font-size-base);line-height:var(--line-height);max-width:1400px;color:var(--text-color);background-color:var(--bg-color);margin:0 auto;padding:40px 20px 20px 0}h1,h2,h3,h4,h5,h6{font-family:var(--font-family-body);margin:var(--heading-margin);line-height:var(--line-height-heading);color:var(--text-color);font-variant:small-caps;max-width:35em}h1{font-size:2.375rem;margin-top:var(--spacing-small)}h2{font-size:1.875rem;margin-top:var(--spacing-xl)}h3{font-size:1.625rem}h4{font-size:1.375rem}p{margin-bottom:var(--spacing-medium);max-width:40em}a{color:var(--link-color);text-decoration:underline}header{margin-bottom:var(--spacing-medium)}.site-header{display:flex;align-items:center;gap:var(--spacing-large);margin-bottom:var(--spacing-medium)}.main-nav{display:flex;gap:var(--spacing-medium);font-size:1rem}</style>
        <link rel="stylesheet" href="/styles/styles.css" media="print" onload="this.media='all'">
        <noscript><link rel="stylesheet" href="/styles/styles.css"></noscript>
        <title>Beyond If Statements and For Loops | salm.dev</title>
            </head>
    <body>
        <div>
            <header>
                <a href="/">home</a> / <a href="/writing/">writing</a>
            </header>
            <article>
                <h1 id="beyond-if-statements-and-for-loops">Beyond If
                Statements and For Loops</h1>
                <div class="description">
                <p>How pattern matching, type systems, and functional
                thinking transformed my approach to solving problems.
                <span class="date-info"><span
                class="date">2025-07-27</span></span></p>
                </div>
                <h2 id="learned-defaults">Learned Defaults</h2>
                <p>Would you believe there is more to writing code than
                if-statements and for-loops? Revelatory, I know. My
                programming flow has traditionally consisted of writing
                nested conditionals, iterating through arrays, wrapping
                errors in try-catches, and hopefully ending up with a
                finished product that <em>works</em>.</p>
                <p>In my intro programming course, we learned basic
                Java. After arrays, we jumped straight into
                object-oriented design, data structures, and algorithms.
                We (briefly) learned the Stream API, but not match
                expressions,
                <code>object instanceof ClassName newVar</code> (inline
                type check and declaration), or <code>var</code>.<sup class="fnref"><a href="#fn1" id="note1" title="Footnote 1">1</a></sup><span class="footnote" id="fn1"><a class="fnref" href="#note1" title="Footnote 1 Reference">1</a> Thanks <a
                href="https://ben.enterprises/">Ben</a> for the list!!</span> The goal was to
                teach us OOP fundamentals, not necessarily to write
                modern Java.</p>
                <p>So we wrote code that was verbose, hard to follow,
                and broke if you looked at it wrong. Functions could do
                anything, fail mysteriously, or modify state in ways I
                couldn’t trace. Looking back, I was living in what I now
                call the “sea of objects”<sup class="fnref"><a href="#fn2" id="note2" title="Footnote 2">2</a></sup><span class="footnote" id="fn2"><a class="fnref" href="#note2" title="Footnote 2 Reference">2</a> This is terminology I learned in
                <em>Programming Rust (2021)</em> describing the tangled
                web of mutable references common in object-oriented
                programming.</span>. Everything
                connected, state flowing unpredictably, dependencies
                knotted together beyond comprehension.</p>
                <p>I spent some time this summer studying idiomatic Rust
                and familiarizing myself with the functional programming
                paradigm. Now, I can confidently say I can represent
                many common programming patterns better than before.</p>
                <p>What does ‘better’ mean? I’d argue we find
                improvement when we discover patterns that represent our
                work more efficiently, intuitively, or clearly.</p>
                <h2 id="pattern-1-pattern-matching">Pattern 1: Pattern
                Matching</h2>
                <p>The first major shift happened when I realized most
                of my if-else chains weren’t about control flow. They
                were about destructuring data and handling different
                shapes. Instead of asking “what should I do in this
                situation?”, I started asking “what shape is my data,
                and how do I handle each shape?”</p>
                <p>Here’s an example of what I used to write:</p>
                <div class="sourceCode" id="cb1"><pre
                class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> process_pokemon(pokemon_data):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> pokemon_data.get(<span class="st">&#39;type&#39;</span>) <span class="op">==</span> <span class="st">&#39;dragon&#39;</span>:</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pokemon_data.get(<span class="st">&#39;evolution_stage&#39;</span>) <span class="op">==</span> <span class="st">&#39;final&#39;</span>:</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> unlock_legendary_moves(pokemon_data)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> locked_to_basic_moves(pokemon_data)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> pokemon_data.get(<span class="st">&#39;type&#39;</span>) <span class="op">==</span> <span class="st">&#39;normal&#39;</span>:</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> access_normal_moves(pokemon_data)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> fallback_struggle(pokemon_data)</span></code></pre></div>
                <p>With match syntax, this becomes:</p>
                <div class="sourceCode" id="cb2"><pre
                class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="cf">match</span> (pokemon<span class="op">.</span>ptype<span class="op">,</span> pokemon<span class="op">.</span>evolution_stage) <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    (Dragon<span class="op">,</span> Final) <span class="op">=&gt;</span> unlock_legendary_moves(pokemon)<span class="op">,</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    (Dragon<span class="op">,</span> _)     <span class="op">=&gt;</span> locked_to_basic_moves(pokemon)<span class="op">,</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    (Normal<span class="op">,</span> _)     <span class="op">=&gt;</span> access_normal_moves(pokemon)<span class="op">,</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    (_<span class="op">,</span> _)          <span class="op">=&gt;</span> fallback_struggle(pokemon)<span class="op">,</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
                <p>I’ll admit I was initially drawn to pattern matching
                because it looked cleaner. What surprised me was how it
                forced me to think about my data’s structure upfront and
                handle all possible cases. The compiler literally won’t
                let me forget an edge case.</p>
                <p>Rust’s pattern matching opened my eyes to a pattern
                I’d been approximating badly in other languages. Once I
                saw it clearly, I realized it’s everywhere. Swift has
                it, Python 3.10+ added it, and I can even fake it in
                JavaScript:</p>
                <div class="sourceCode" id="cb3"><pre
                class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">// approximated in js w/ objects</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> moveHandlers <span class="op">=</span> {</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">&#39;dragon:final&#39;</span><span class="op">:</span> (pokemon) <span class="kw">=&gt;</span> <span class="fu">unlockLegendaryMoves</span>(pokemon)<span class="op">,</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">&#39;dragon:basic&#39;</span><span class="op">:</span> (pokemon) <span class="kw">=&gt;</span> <span class="fu">lockedToBasicMoves</span>(pokemon)<span class="op">,</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="st">&#39;normal&#39;</span><span class="op">:</span> (pokemon) <span class="kw">=&gt;</span> <span class="fu">accessNormalMoves</span>(pokemon)<span class="op">,</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>}<span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> key <span class="op">=</span> <span class="vs">`</span><span class="sc">${</span>pokemon<span class="op">.</span><span class="at">type</span><span class="sc">}</span><span class="vs">:</span><span class="sc">${</span>pokemon<span class="op">.</span><span class="at">evolutionStage</span><span class="sc">}</span><span class="vs">`</span><span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="cf">return</span> moveHandlers[key]<span class="op">?.</span>(pokemon) <span class="op">||</span> <span class="fu">fallbackStruggle</span>(pokemon)<span class="op">;</span></span></code></pre></div>
                <p>The insight isn’t superior syntax. It’s realizing
                that sometimes I’m better served thinking about data
                shapes instead of control flow.</p>
                <h2 id="pattern-2-types">Pattern 2: Types</h2>
                <p>Match syntax is a clean and effective way to process
                different data shapes, but it’s just one part of the
                puzzle. Another question is how we represent our data in
                the first place.</p>
                <p>Here’s the kind of code I used to write:</p>
                <div class="sourceCode" id="cb4"><pre
                class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> questLog <span class="op">=</span> {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">status</span><span class="op">:</span> <span class="st">&#39;active&#39;</span><span class="op">,</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">questId</span><span class="op">:</span> <span class="st">&#39;save-the-village&#39;</span><span class="op">,</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">rewards</span><span class="op">:</span> <span class="kw">null</span><span class="op">,</span>         <span class="co">// only exists when completed</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">failureReason</span><span class="op">:</span> <span class="kw">null</span><span class="op">,</span>   <span class="co">// only exists when failed</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">currentObjective</span><span class="op">:</span> <span class="dv">0</span><span class="op">,</span>   <span class="co">// meaningless when completed or failed</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>}<span class="op">;</span></span></code></pre></div>
                <p>What I learned was to make illegal states
                unrepresentable.</p>
                <p>Now I design with the type system:</p>
                <div class="sourceCode" id="cb5"><pre
                class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> QuestState <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    Available <span class="op">{</span> questId<span class="op">:</span> QuestId<span class="op">,</span> requirements<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span>Requirement<span class="op">&gt;</span> <span class="op">},</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    Active <span class="op">{</span> questId<span class="op">:</span> QuestId<span class="op">,</span> currentObjective<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span> progress<span class="op">:</span> Progress <span class="op">},</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    Completed <span class="op">{</span> questId<span class="op">:</span> QuestId<span class="op">,</span> rewards<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span>Reward<span class="op">&gt;,</span> completedAt<span class="op">:</span> DateTime <span class="op">},</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    Failed <span class="op">{</span> questId<span class="op">:</span> QuestId<span class="op">,</span> reason<span class="op">:</span> FailureReason<span class="op">,</span> canRetry<span class="op">:</span> <span class="dt">bool</span> <span class="op">},</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
                <p>I literally cannot have a completed quest without
                rewards or an active quest without progress
                tracking.</p>
                <p>I’ve realized the value in using the type system to
                encode business rules, not just data shapes. When
                illegal states become unrepresentable, entire categories
                of bugs disappear.</p>
                <p>Rust showed me this principle clearly, but once I
                understood it, I could apply it elsewhere. With
                TypeScript’s discriminated unions, or even factory
                functions in dynamic languages.</p>
                <h2 id="pattern-3-transformations">Pattern 3:
                Transformations</h2>
                <p>Another way I realized I could clean up my code is by
                replacing many of my for-loops. Most of them weren’t
                really for iteration. They were transformations. I was
                manually implementing map, filter, and reduce operations
                when I didn’t need to.</p>
                <p>My manual approach:</p>
                <div class="sourceCode" id="cb6"><pre
                class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_raid_damage(party_members):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    total_damage <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> member <span class="kw">in</span> party_members:</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> member.is_alive <span class="kw">and</span> <span class="kw">not</span> member.is_stunned:  <span class="co"># filter</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>            damage <span class="op">=</span> member.base_damage <span class="op">*</span> member.gear_multiplier  <span class="co"># map</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> member.has_buff(<span class="st">&#39;berserk&#39;</span>):</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>                damage <span class="op">*=</span> <span class="fl">1.5</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>            total_damage <span class="op">+=</span> damage  <span class="co"># reduce</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total_damage</span></code></pre></div>
                <p>What I learned:</p>
                <div class="sourceCode" id="cb7"><pre
                class="sourceCode rust"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> calculate_raid_damage(party<span class="op">:</span> <span class="op">&amp;</span>[PartyMember]) <span class="op">-&gt;</span> <span class="dt">f64</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    party<span class="op">.</span>iter()</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>filter(<span class="op">|</span>member<span class="op">|</span> member<span class="op">.</span>is_alive <span class="op">&amp;&amp;</span> <span class="op">!</span>member<span class="op">.</span>is_stunned)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>map(<span class="op">|</span>member<span class="op">|</span> <span class="op">{</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> damage <span class="op">=</span> member<span class="op">.</span>base_damage <span class="op">*</span> member<span class="op">.</span>gear_multiplier<span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> member<span class="op">.</span>has_buff(<span class="pp">BuffType::</span>Berserk) <span class="op">{</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>                damage <span class="op">*</span> <span class="dv">1.5</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>                damage</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>sum()</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
                <p>It’s more honest about intent. The chain of
                operations tells me exactly what’s happening: filter
                active members, calculate their damage with multipliers,
                sum the results.</p>
                <h3 id="zero-cost-iterators">Zero-Cost Iterators</h3>
                <p>These iterator chains compile to highly optimized
                assembly. The compiler transforms them into tight loops
                with minimal overhead, though “zero-cost” is more
                aspiration than guarantee. Complex chains can sometimes
                hit optimization limits. But for most code, you get
                beautiful, functional patterns that run as fast as
                manual loops.</p>
                <h2 id="pattern-4-error-handling">Pattern 4: Error
                Handling</h2>
                <p>Error handling was where my old patterns really broke
                down. I went through a clear evolution that was honestly
                pretty embarrassing in retrospect:</p>
                <h3 id="exception-hell">“Exception Hell”</h3>
                <p>You’ve definitely been here before. Look
                familiar?</p>
                <div class="sourceCode" id="cb8"><pre
                class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> brew_coffee(order):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        beans <span class="op">=</span> grind_beans(order.bean_type)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>            water <span class="op">=</span> heat_water(order.temperature)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">try</span>:</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>                coffee <span class="op">=</span> brew(beans, water, order.brew_time)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> coffee</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">except</span> BrewError <span class="im">as</span> e:</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>                log_error(e)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>                <span class="cf">raise</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> WaterError <span class="im">as</span> e:</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>            log_error(e)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> CoffeeError(<span class="st">&quot;Water heating failed&quot;</span>) <span class="im">from</span> e</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> GrindError <span class="im">as</span> e:</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        log_error(e)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span>  <span class="co"># sometimes return None, sometimes raise?</span></span></code></pre></div>
                <p>I tried to get smarter about this by making errors
                explicit in return types:</p>
                <h3 id="again-but-with-explicit-results">Again, but with
                Explicit Results</h3>
                <div class="sourceCode" id="cb9"><pre
                class="sourceCode typescript"><code class="sourceCode typescript"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> BrewResult <span class="op">=</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> { success<span class="op">:</span> <span class="kw">true</span><span class="op">;</span> coffee<span class="op">:</span> Coffee }</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> { success<span class="op">:</span> <span class="kw">false</span><span class="op">;</span> error<span class="op">:</span> <span class="dt">string</span> }<span class="op">;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">brewCoffee</span>(order<span class="op">:</span> Order)<span class="op">:</span> BrewResult {</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// at least now I know this function can fail</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
                <p>This was better, but chaining these operations was
                still awkward. Then I learned Rust!!</p>
                <h3 id="the-way-of-rust">The Way of Rust</h3>
                <p>Learning Rust’s <code>Result&lt;T, E&gt;</code> and
                the <code>?</code> operator was transformative:</p>
                <div class="sourceCode" id="cb10"><pre
                class="sourceCode rust"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> brew_coffee(order<span class="op">:</span> <span class="op">&amp;</span>Order) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>Coffee<span class="op">,</span> CoffeeError<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> beans <span class="op">=</span> grind_beans(<span class="op">&amp;</span>order<span class="op">.</span>bean_type)<span class="op">?;</span>         <span class="co">// stop if grind fails</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> water <span class="op">=</span> heat_water(order<span class="op">.</span>temperature)<span class="op">?;</span>         <span class="co">// stop if heating fails</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> coffee <span class="op">=</span> brew(beans<span class="op">,</span> water<span class="op">,</span> order<span class="op">.</span>brew_time)<span class="op">?;</span>  <span class="co">// stop if brew fails</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Ok</span>(coffee)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
                <p>Each <code>?</code> says “if this step fails, stop
                here and return the error.” The function signature tells
                me exactly what can go wrong.</p>
                <p>The <code>?</code> operator itself is Rust magic, but
                the pattern of making errors explicit and composable is
                universal: JavaScript Promises, Go’s error returns, even
                optional chaining. Instead of hoping functions won’t
                throw, I design them so they can’t hide their failure
                modes.</p>
                <h2 id="pattern-5-functions-that-tell-the-truth">Pattern
                5: Functions That Tell the Truth</h2>
                <p>I was pleasantly surprised to find that function
                signatures in Rust are complete contracts:</p>
                <div class="sourceCode" id="cb11"><pre
                class="sourceCode rust"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">// this function promises it won&#39;t store the reference</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> process_temporarily(data<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">usize</span> <span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    data<span class="op">.</span>len()  <span class="co">// calculates length and returns</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co">// this admits it might fail</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> parse_number(s<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">,</span> ParseIntError<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    s<span class="op">.</span>parse()  <span class="co">// failure is part of the type</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
                <p>Put another way, I literally can’t write a function
                that does sneaky stuff without declaring it upfront. The
                signature tells you everything: it takes a string
                reference, might fail, returns an integer on success,
                and specifies the exact error type.</p>
                <p>This honesty extends to how functions compose. What
                seemed like academic wizardry (monads!) turned out to be
                just chaining operations where each step depends on the
                previous one’s result.</p>
                <div class="sourceCode" id="cb12"><pre
                class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">// sequential dependency (must be serial)</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> processUser <span class="op">=</span> <span class="kw">async</span> (id) <span class="kw">=&gt;</span> {</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const</span> user <span class="op">=</span> <span class="cf">await</span> <span class="fu">fetchUser</span>(id)<span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const</span> profile <span class="op">=</span> <span class="cf">await</span> <span class="fu">fetchProfile</span>(user<span class="op">.</span><span class="at">profileId</span>)<span class="op">;</span>  <span class="co">// depends on user</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const</span> settings <span class="op">=</span> <span class="cf">await</span> <span class="fu">fetchSettings</span>(profile<span class="op">.</span><span class="at">type</span>)<span class="op">;</span>  <span class="co">// depends on profile</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="fu">combineData</span>(user<span class="op">,</span> profile<span class="op">,</span> settings)<span class="op">;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>}<span class="op">;</span></span></code></pre></div>
                <p>That async/await chain? That’s monadic composition.
                Each step feeds its result to the next step, which can
                examine that result and decide what to do. Once Rust
                taught me to see this pattern, I realized I’d been using
                monads all along in JavaScript Promises, optional
                chaining, even error handling.</p>
                <p>Error handling:</p>
                <div class="sourceCode" id="cb13"><pre
                class="sourceCode rust"><code class="sourceCode rust"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> process_data(input<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>Output<span class="op">,</span> <span class="bu">Error</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    parse_input(input)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>and_then(<span class="op">|</span>data<span class="op">|</span> validate_data(data))           <span class="co">// runs if parse succeeded</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>and_then(<span class="op">|</span>valid<span class="op">|</span> transform_data(valid))        <span class="co">// runs if validation succeeded</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>and_then(<span class="op">|</span>transformed<span class="op">|</span> save_data(transformed)) <span class="co">// runs if transform succeeded</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
                <p>Optional values:</p>
                <div class="sourceCode" id="cb14"><pre
                class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> getConfig <span class="op">=</span> (user) <span class="kw">=&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">getUser</span>(user<span class="op">.</span><span class="at">id</span>)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">?.</span><span class="fu">getProfile</span>()       <span class="co">// only if user exists</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">?.</span><span class="fu">getSettings</span>()      <span class="co">// only if profile exists</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">?.</span><span class="fu">getTheme</span>()         <span class="co">// only if settings exist</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">??</span> defaultTheme<span class="op">;</span>     <span class="co">// fallback if any step fails</span></span></code></pre></div>
                <p>Scary name, simple idea. It’s just chaining
                operations.</p>
                <h2
                id="pattern-6-performance-without-compromise">Pattern 6:
                Performance Without Compromise</h2>
                <p>One of the biggest revelations was that these
                “high-level” patterns often produce faster code than
                manual imperative approaches.</p>
                <div class="sourceCode" id="cb15"><pre
                class="sourceCode rust"><code class="sourceCode rust"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">// this functional-style code...</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> process_large_dataset(data<span class="op">:</span> <span class="op">&amp;</span>[<span class="dt">f64</span>]) <span class="op">-&gt;</span> <span class="dt">f64</span> <span class="op">{</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    data<span class="op">.</span>par_iter()                    <span class="co">// parallel processing</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>filter(<span class="op">|&amp;&amp;</span>x<span class="op">|</span> x <span class="op">&gt;</span> <span class="dv">0.0</span>)         <span class="co">// skip negative values</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>map(<span class="op">|&amp;</span>x<span class="op">|</span> x<span class="op">.</span>sqrt())            <span class="co">// square root transformation</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>map(<span class="op">|</span>x<span class="op">|</span> x <span class="op">*</span> <span class="dv">2.0</span>)              <span class="co">// scale by 2</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>sum()                         <span class="co">// parallel reduction</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="co">// ...compiles to vectorized assembly that uses SIMD instructions</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="co">// and parallel execution across CPU cores</span></span></code></pre></div>
                <p>I found that modern compilers could optimize my
                functional patterns better because:</p>
                <ol type="1">
                <li>Clear data flow: transformations can be vectorized
                automatically</li>
                <li>No side effects: aggressive optimization is
                safe</li>
                <li>Parallelizable: no shared mutable state means easy
                parallelization</li>
                <li>Compiler can reorder operations: pure functions give
                the compiler more freedom</li>
                </ol>
                <h3 id="memory-safety-without-garbage-collection">Memory
                Safety Without Garbage Collection</h3>
                <p>Rust taught me that the choice between performance
                and safety is a false dichotomy:</p>
                <div class="sourceCode" id="cb16"><pre
                class="sourceCode rust"><code class="sourceCode rust"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">// rust: safe AND fast</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> process(huge_dataset<span class="op">:</span> <span class="op">&amp;</span>[<span class="dt">String</span>]) <span class="op">-&gt;</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    huge_dataset<span class="op">.</span>iter()</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>map(<span class="op">|</span>item<span class="op">|</span> expensive_transform(item))</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>collect()</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// memory safety guaranteed at compile time</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// no GC pauses, no leaks, no undefined behavior</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// performance identical to C++</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
                <p>By making ownership explicit in the type system, Rust
                eliminates the runtime overhead of safety checks.</p>
                <p>Rust shows that the choice between performance and
                safety is false. You can have both. The broader lesson
                applies everywhere: modern engines have largely closed
                the performance gap between functional patterns and
                manual loops. The old excuse of ‘functional programming
                is too slow’ doesn’t hold up anymore.</p>
                <h2 id="pattern-7-composition">Pattern 7:
                Composition</h2>
                <p>Another crucial pattern was learning to build complex
                behavior from simple, composable pieces.</p>
                <p>Before, I had massive, monolithic functions:</p>
                <div class="sourceCode" id="cb17"><pre
                class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> craft_legendary_weapon(player, materials, recipe):</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 200+ lines of mixed concerns:</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># validate materials, check requirements, consume resources</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># calculate success chance, apply buffs, handle failures, etc.</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">pass</span></span></code></pre></div>
                <p>Then, I tried refactoring to composable
                pipelines:</p>
                <div class="sourceCode" id="cb18"><pre
                class="sourceCode rust"><code class="sourceCode rust"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> craft_legendary_weapon(</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    player<span class="op">:</span> <span class="op">&amp;</span>Player<span class="op">,</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    materials<span class="op">:</span> Materials<span class="op">,</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    recipe<span class="op">:</span> Recipe<span class="op">,</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>LegendaryWeapon<span class="op">,</span> CraftingError<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    recipe</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>validate_materials(<span class="op">&amp;</span>materials)<span class="op">?</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>check_player_level(player)<span class="op">?</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>check_crafting_skill(player)<span class="op">?</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>consume_materials(<span class="op">&amp;</span><span class="kw">mut</span> player<span class="op">.</span>inventory)<span class="op">?</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>calculate_success_chance(player<span class="op">.</span>stats)<span class="op">?</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>attempt_craft()<span class="op">?</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>apply_enchantments(player<span class="op">.</span>available_enchants)<span class="op">?</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>finalize()</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
                <p>Each function has a clear contract and no side
                effects. I can test them in isolation, combine them in
                different ways, and reason about the whole system by
                understanding the parts.</p>
                <h2 id="pattern-8-ownership">Pattern 8: Ownership!</h2>
                <p>Here we are at last! Rust’s ownership system
                transformed how I think about data relationships, not
                just in Rust, but everywhere.</p>
                <p>Traditional object-oriented thinking creates a
                tangled mess where everything points to everything
                else:</p>
                <div style="display: flex; gap: 40px; margin: 20px 0;">
                <div style="text-align: center;">
                <img src="images/sea-of-objects.jpeg" alt="Sea of objects diagram" style="width: 300px;">
                <div style="font-style: italic; margin-top: 8px;">
                Sea of Objects (Traditional OOP)
                </div>
                </div>
                <div style="text-align: center;">
                <img src="images/tree-of-values.jpeg" alt="Tree of values diagram" style="width: 245px;">
                <div style="font-style: italic; margin-top: 8px;">
                Tree of Values (Rust’s Ownership)
                </div>
                </div>
                </div>
                <p>Following data flow becomes impossible in the
                traditional model:</p>
                <div class="sourceCode" id="cb19"><pre
                class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># complex &quot;web&quot; of mutable references</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> QuestLog:</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.quests <span class="op">=</span> []</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.active_quest <span class="op">=</span> <span class="va">None</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Quest:</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, quest_log):</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.quest_log <span class="op">=</span> quest_log</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>        quest_log.quests.append(<span class="va">self</span>)  <span class="co"># quest modifies its container</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>        quest_log.active_quest <span class="op">=</span> <span class="va">self</span>   <span class="co"># mutation from constructor</span></span></code></pre></div>
                <p>Rust’s ownership system enforces a “tree of values”
                where each piece of data has exactly one owner:</p>
                <div class="sourceCode" id="cb20"><pre
                class="sourceCode rust"><code class="sourceCode rust"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> QuestLog <span class="op">{</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    quests<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span>Quest<span class="op">&gt;,</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    active_quest_id<span class="op">:</span> <span class="dt">Option</span><span class="op">&lt;</span>QuestId<span class="op">&gt;,</span>  <span class="co">// ID-based reference</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Quest <span class="op">{</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    id<span class="op">:</span> QuestId<span class="op">,</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    name<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    objectives<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span>Objective<span class="op">&gt;,</span>  <span class="co">// quest owns its objectives</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
                <p>Using IDs instead of direct references is a common
                pattern in Rust (and game development generally) to work
                around ownership restrictions while maintaining
                safety.</p>
                <p>Now I’ll grant that I can’t enforce these ownership
                rules in Python or JavaScript. But understanding the
                model itself has transformed how I design systems
                everywhere.</p>
                <h3 id="the-constraint-solver-mindset">The
                Constraint-Solver Mindset</h3>
                <p>Everyone talks about “fighting the borrow checker,”
                and yeah, at first it’s infuriating:</p>
                <div class="sourceCode" id="cb21"><pre
                class="sourceCode rust"><code class="sourceCode rust"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">// this won&#39;t compile:</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> data <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> first <span class="op">=</span> <span class="op">&amp;</span>data[<span class="dv">0</span>]<span class="op">;</span>     <span class="co">// immutable borrow</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>data<span class="op">.</span>push(<span class="dv">6</span>)<span class="op">;</span>             <span class="co">// mutable borrow - ERROR!</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> first)<span class="op">;</span>    <span class="co">// use of immutable borrow</span></span></code></pre></div>
                <p>My first reaction was pure frustration. Why won’t the
                compiler let me do this simple thing?</p>
                <p>But then I realized: this code was always dangerous.
                In C++, <code>data.push_back(6)</code> might reallocate
                the vector, making <code>first</code> a dangling
                pointer. The program might crash, or worse, silently
                corrupt memory. Rust just makes the problem visible at
                compile time.</p>
                <p>This changed how I think about data dependencies. Now
                I ask: What owns this data? What can modify it, and
                when? How can I design this to minimize shared mutable
                state?</p>
                <p>And the whole time, the compiler is showing me
                problems I didn’t even know existed. Hardly the nature
                of an enemy.</p>
                <h2 id="beyond-the-defaults">Beyond the Defaults</h2>
                <p>All of these patterns changed something fundamental.
                I used to obsess over the exact sequence of steps: this
                loop, then that condition, then update this variable.
                Now I think more about transformations: take this data,
                filter it, transform it, combine it.</p>
                <p>When I stopped mutating everything in sight,
                parallelization got easier. When functions started
                telling the truth about what they could fail at, I spent
                less time in the debugger. When I learned to build big
                things from small, composable pieces, the complexity
                became less overwhelming. Not everything improved—Rust’s
                ownership makes performance more predictable, sure, but
                in other languages I’m still guessing. But overall? The
                code is easier to reason about. Bugs tend to be
                shallower.</p>
                <p>I started small. One complex if-else chain became a
                lookup table. Then I noticed some of my for-loops were
                really just filters and maps in disguise. The compiler
                was vexing at first. Like, genuinely maddening. But
                those moments when things finally clicked, when I
                understood why the borrow checker was saving me from
                myself, made it worth pushing through. Each pattern made
                the next one easier to see.</p>
                <p>I still write if-statements and for-loops. Of course
                I do. But now I know when I’m choosing them, not
                defaulting to them. When I reach for a nested
                conditional now, I pause. Is this about control flow, or
                am I destructuring data? When I start a for-loop, I ask:
                am I iterating, or transforming?</p>
                <p>Would you believe there is more to writing code than
                if-statements and for-loops? Turns out, yeah. There
                really is.</p>
                <aside id="footnotes"
                class="footnotes footnotes-end-of-document"
                role="doc-endnotes">
                <hr />
                <ol>
                <li id="fn1"><p>Thanks <a
                href="https://ben.enterprises/">Ben</a> for the list!!<a
                href="#fnref1" class="footnote-back"
                role="doc-backlink">↩︎</a></p></li>
                <li id="fn2"><p>This is terminology I learned in
                <em>Programming Rust (2021)</em> describing the tangled
                web of mutable references common in object-oriented
                programming.<a href="#fnref2" class="footnote-back"
                role="doc-backlink">↩︎</a></p></li>
                </ol>
                </aside>
            </article>
<div class="the-end">~ fin ~</div><div class="similar-writing"><div class="post-navigation"><div class="nav-prev">← Prev: <a href="/writing/create-dont-consume/">Create, Don't Consume</a></div><div class="nav-next">Next: <a href="/writing/cs-data-science-done-right/">CS + Data Science Done Right</a> →</div></div></div>
        </div>
        <footer>
            <p>© 2025 salm.dev | nico@salm.dev | <a href="https://status.salm.dev/" target="_blank">status</a></p>
        </footer>
        <script
        src="https://tracking.salm.dev/api/script.js"
        data-site-id="a3641cc346e8"
        defer
    ></script>
    </body>
</html>
