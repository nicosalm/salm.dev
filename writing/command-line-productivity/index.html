<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/svg+xml" href="/assets/favicon.svg">
<style>
@font-face {
    font-family: 'firasans';
    font-style: normal;
    font-weight: normal;
    font-stretch: normal;
    font-display: swap;
    src: url('/assets/fonts/firasans_regular.woff2') format('woff2');
}

@font-face {
    font-family: 'firasans';
    font-style: italic;
    font-weight: normal;
    font-stretch: normal;
    font-display: swap;
    src: url('/assets/fonts/firasans_italic.woff2') format('woff2');
}

@font-face {
    font-family: 'charter';
    font-style: normal;
    font-weight: normal;
    font-stretch: normal;
    font-display: swap;
    src: url('/assets/fonts/charter_regular.woff2') format('woff2');
}

@font-face {
    font-family: 'charter';
    font-style: italic;
    font-weight: normal;
    font-stretch: normal;
    font-display: swap;
    src: url('/assets/fonts/charter_italic.woff2') format('woff2');
}

@font-face {
    font-family: 'charter';
    font-style: normal;
    font-weight: bold;
    font-stretch: normal;
    font-display: swap;
    src: url('/assets/fonts/charter_bold.woff2') format('woff2');
}

@font-face {
    font-family: 'charter';
    font-style: italic;
    font-weight: bold;
    font-stretch: normal;
    font-display: swap;
    src: url('/assets/fonts/charter_bold_italic.woff2') format('woff2');
}

@font-face {
    font-family: 'firacode';
    src: url('/assets/fonts/firacode_regular.woff2') format('woff2');
    font-weight: normal;
    font-style: normal;
    font-display: swap;
}

:root {
    --bg-color: #ffffff;
    --text-color: #333333;
    --text-light: #555555;
    --text-gray: #666666;
    --link-color: #0066cc;
    --border-color: #eee;
    --border-dark: #000;
    --code-bg: #f5f5f5;
    --blockquote-bg: #f9f9f9;
    --blockquote-border: #ccc;
    --nav-light: #f8f8f8;
    --nav-dark: #f0f0f0;
    --webring-primary: #C5050C;
    --webring-bg: #FFFFFF;

    --font-family-body: charter, Georgia, serif;
    --font-family-headers: firasans, Georgia, serif;
    --font-family-code: firacode, Consolas, monospace;

    --font-size-base: 1rem;
    --font-size-small: 0.9rem;
    --line-height: 1.6;
    --line-height-tight: 1.1;
    --line-height-heading: 1.2;
    --spacing-tiny: 0.25rem;
    --spacing-small: 0.5rem;
    --spacing-medium: 1rem;
    --spacing-large: 1.5rem;
    --spacing-xl: 2rem;
    --spacing-huge: 3rem;
    --max-width: 1000px;
    --transition-speed: 0.3s ease;
}

@media (prefers-color-scheme: dark) {
    :root {
        --bg-color: #1a1a1a;
        --text-color: #e0e0e0;
        --text-light: #b0b0b0;
        --text-gray: #888888;
        --link-color: #66aaff;
        --border-color: #333;
        --border-dark: #555;
        --code-bg: #2a2a2a;
        --blockquote-bg: #2a2a2a;
        --blockquote-border: #555;
        --nav-light: #2a2a2a;
        --nav-dark: #333333;
        --webring-primary: #ff4444;
        --webring-bg: #2a2a2a;
    }

    header.main-nav img[src="/assets/logo-black.svg"] {
        content: url("/assets/logo-white.svg");
    }

    .post-link[data-description]:hover::after {
        background-color: #2a2a2a !important;
        border: 1px solid #555 !important;
        color: var(--text-light) !important;
        box-shadow: 0 4px 8px rgba(0,0,0,0.3) !important;
    }
}

* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    font-family: var(--font-family-body);
    font-size: var(--font-size-base);
    line-height: var(--line-height);
    max-width: var(--max-width);
    color: var(--text-color);
    background-color: var(--bg-color);
    margin: 0 auto;
    padding: 20px;
    transition: background-color var(--transition-speed), color var(--transition-speed);
}

h1, h2, h3, h4, h5, h6 {
    font-family: var(--font-family-headers);
    margin: var(--spacing-large) 0 var(--spacing-medium);
    line-height: var(--line-height-heading);
    color: var(--text-color);
}

h1 { font-size: 2rem; }
h2 {
    font-size: 1.5rem;
    margin-top: var(--spacing-xl);
}
h3 { font-size: 1.25rem; }

p {
    margin-bottom: var(--spacing-medium);
}

a {
    color: var(--link-color);
    text-decoration: none;
    transition: color var(--transition-speed);
}

a:hover {
    text-decoration: underline;
}

ul, ol {
    margin: var(--spacing-medium) 0;
    padding-left: var(--spacing-xl);
}

li {
    margin-bottom: var(--spacing-tiny);
}

table {
    width: 100%;
    border-collapse: collapse;
    margin: var(--spacing-medium) 0;
    font-size: var(--font-size-base);
}

th, td {
    padding: var(--spacing-small) var(--spacing-medium);
    text-align: left;
    border-bottom: 1px solid var(--border-color);
    transition: border-color var(--transition-speed);
}

th {
    font-weight: bold;
    color: var(--text-color);
    border-bottom: 2px solid var(--border-dark);
}

blockquote {
    margin: var(--spacing-large) 0;
    padding: var(--spacing-small) var(--spacing-large);
    border-left: 3px solid var(--blockquote-border);
    color: var(--text-light);
    font-style: italic;
    background-color: var(--blockquote-bg);
    transition: background-color var(--transition-speed), border-color var(--transition-speed);
}

blockquote p {
    margin-bottom: var(--spacing-small);
}

blockquote p:last-child {
    margin-bottom: 0;
}

code {
    font-family: var(--font-family-code);
    background-color: var(--code-bg);
    color: var(--text-color);
    padding: 0.2rem 0.4rem;
    border-radius: 3px;
    font-size: var(--font-size-small);
    white-space: pre-wrap;
    word-wrap: break-word;
    transition: background-color var(--transition-speed);
}

pre {
    background-color: var(--code-bg);
    padding: var(--spacing-medium);
    border-radius: 3px;
    overflow-x: auto;
    margin: var(--spacing-medium) 0;
    transition: background-color var(--transition-speed);
}

pre code {
    padding: 0;
    background-color: transparent;
}

img {
    max-width: 100%;
    height: auto;
    display: block;
    margin: var(--spacing-small) var(--spacing-tiny);
}

figure {
    margin: 0;
    text-align: center;
}

figcaption {
    font-size: var(--font-size-small);
    margin-top: 5px;
    font-style: italic;
    color: var(--text-light);
}

header {
    margin-bottom: var(--spacing-medium);
}

footer {
    margin-top: var(--spacing-huge);
    text-align: center;
    font-size: var(--font-size-small);
    color: var(--text-gray);
    border-top: 1px solid var(--border-color);
    padding-top: var(--spacing-medium);
    transition: border-color var(--transition-speed);
}

hr.solid {
    border: 0;
    border-top: 1px solid var(--border-dark);
    margin: var(--spacing-large) 0;
    transition: border-color var(--transition-speed);
}

header.main-nav {
    display: flex;
    flex-direction: column;
    align-items: center;
}

header.main-nav img {
    margin-bottom: 15px;
    margin-right: 0;
}

header.main-nav nav {
    width: 100%;
    overflow-x: auto;
}

.nav-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 0;
    line-height: var(--line-height-tight);
    min-width: max-content;
}

.nav-header,
.nav-cell {
    padding: 2px;
}

.nav-cell {
    padding-bottom: 1px;
}

.light-row {
    background-color: var(--nav-light);
    transition: background-color var(--transition-speed);
}

.dark-row {
    background-color: var(--nav-dark);
    transition: background-color var(--transition-speed);
}

@media (min-width: 576px) {
    header.main-nav {
        flex-direction: row;
        align-items: flex-start;
    }

    header.main-nav img {
        margin-right: 80px;
        margin-bottom: 0;
    }
}

.buttons-layout {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
}

.buttons-container {
    display: flex;
    flex-wrap: wrap;
    gap: var(--spacing-small);
}

.button-88x31 {
    width: 88px;
    height: 31px;
    margin: 0;
}

.post-link {
    position: relative;
    display: inline-block;
}

.post-link[data-description]:hover::after {
    content: attr(data-description);
    position: absolute;
    left: 0;
    top: 100%;
    margin-top: 5px;
    z-index: 1;
    width: 320px;
    background-color: var(--bg-color);
    padding: 10px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    color: var(--text-light);
    font-size: var(--font-size-small);
    line-height: 1.4;
    pointer-events: none;
    transition: all var(--transition-speed);
}

.webring {
    width: 100%;
    border: 1px solid var(--webring-primary);
    max-width: 250px;
    transition: border-color var(--transition-speed);
}

.webring-header {
    background-color: var(--webring-primary);
    text-align: center;
    color: #FFFFFF;
    transition: background-color var(--transition-speed);
}

.webring-links {
    background-color: var(--webring-bg);
    text-align: center;
    white-space: nowrap;
    transition: background-color var(--transition-speed);
}

.webring-links a {
    color: var(--webring-primary);
    transition: color var(--transition-speed);
}

@media (max-width: 576px) {
    .about-container {
        flex-direction: column !important;
        align-items: center !important;
    }

    .about-container img {
        margin-bottom: 20px !important;
        order: -1 !important;
    }
}
</style>
    <title>Command Line Productivity | salm.dev</title>
        <script src="/assets/js/mathjax-config.js"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    <link rel="preconnect" href="https://cdn.jsdelivr.net">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" as="script">
    </head>
<body>
    <div>
        <header>
            <a href="/">home</a> / <a href="/writing/">writing</a>
        </header>
        <article>
            <h1 id="command-line-productivity">Command Line
            Productivity</h1>
            <p>Date: 2024-10-10</p>
            <blockquote>
            <p>I am not a fan of bloated workflows or feature overload.
            In this article, I describe my minimal, focused,
            keyboard-centric workflow where I do my best work. In other
            words: I shill vim.</p>
            </blockquote>
            <h2 id="motivation">Motivation</h2>
            <p>The purpose of this article isn’t to persuade you to
            radically overhaul your development workflow overnight, nor
            is it a critique of “mainstream” editors and IDEs. My aim is
            to share my perspective and introduce you to an alternative
            (and in my opinion, more performant) set of tools that have
            worked well for me.</p>
            <p>In my view, there are two distinct domains of technical
            productivity:</p>
            <ol type="1">
            <li><p>Tools, such as those for version control (Git) and
            repository hosting (GitHub, GitLab) – these systems
            fundamentally improve how you work. They’re your safety net
            and scaffolding for when things go awry and have a place in
            every developer’s workflow.</p></li>
            <li><p>On the other side, there are tools and tweaks
            designed to genuinely accelerate your development process
            (and subsequently, the rate which you complete tasks). These
            tools are what I will be highlighting today.</p></li>
            </ol>
            <p>In order, I’ll discuss: the shell, command line tools,
            multiplexers, text editors, cases for automation, and
            development integration. We’ll end things with a mental
            model bringing it all together.</p>
            <h3 id="what-were-not-covering-but-is-also-important">What
            We’re Not Covering (But Is Also Important)</h3>
            <p>This post talks about productivity tools and techniques
            which I feel will have the biggest impact for most users.
            I’m leaving out several foundational (but less
            productivity-focused) areas: hardware (keyboard layouts,
            system performance factors), operating system choices (FS
            architecture, process management, etc.), system admin and
            low-level configuration, and container tools (docker,
            podman).</p>
            <h2 id="the-shell">The Shell</h2>
            <p>Your shell is the foundation that every other tool builds
            upon, and frankly, most people are not taking full advantage
            of it.</p>
            <p>The default bash that ships with most systems is… fine.
            However, if you’re serious about command line productivity,
            you need to upgrade to something modern. I recommend
            <strong>zsh</strong> with a framework like <a
            href="https://ohmyz.sh/">Oh My Zsh</a>, or if you want
            something that works beautifully out of the box, try
            <strong>fish</strong>.</p>
            <p>Here’s what you get with a modern shell that bash simply
            can’t match:</p>
            <ul>
            <li><p>Intelligent autocompletion that actually understands
            context. Type <code>git</code> and hit tab—it knows you
            probably want <code>add</code>, <code>commit</code>, or
            <code>push</code>, not some random file in your
            directory.</p></li>
            <li><p>Syntax highlighting in real time. Mistype a command?
            It turns red before you even hit enter. No more “command not
            found”.</p></li>
            <li><p>History search that doesn’t suck. Hit
            <code>Ctrl+R</code> and type a few letters—kablam! There’s
            the command.</p></li>
            </ul>
            <p>But before we dive into configuration, can we talk about
            something that drives me absolutely insane? Please, for the
            love of all that is holy, <i><strong>resize your terminal
            window!</strong></i> I see people working in these tiny
            80x24 windows like it’s 1985. You have a 27-inch monitor and
            you’re squinting at 12 lines of code at a time. Make your
            terminal bigger. Much bigger!</p>
            <p>Now, for the content of substance. First we must
            configure the shell. That means creating aliases to
            eliminate the <em>friction</em><a href="#fn1"
            class="footnote-ref" id="fnref1"
            role="doc-noteref"><sup>1</sup></a> from your daily
            workflow:</p>
            <div class="sourceCode" id="cb1"><pre
            class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="bu">alias</span> v=<span class="st">&#39;nvim&#39;</span>                          <span class="co"># why type 4 letters when 1 will do?</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="bu">alias</span> c=<span class="st">&#39;clear&#39;</span>                         <span class="co"># (alternatively: CMD/CTRL-L)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="bu">alias</span> j=<span class="st">&#39;jobs&#39;</span>                          <span class="co"># see what&#39;s running in the background</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="bu">alias</span> ev=<span class="st">&#39;cd ~/.config/nvim/ &amp;&amp; nvim .&#39;</span> <span class="co"># jump to editor config</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="bu">alias</span> ...=<span class="st">&quot;cd ../..&quot;</span>                    <span class="co"># jump back two dirs</span></span></code></pre></div>
            <p>Beyond just saving keystrokes, you’re reducing the mental
            overhead of context switching. When you want to edit your
            Neovim config, you don’t want to remember the path and type
            out two commands. You want to type <code>ev</code> and be
            there.</p>
            <p>Write functions for operations that are slightly too
            complex for aliases:</p>
            <div class="sourceCode" id="cb2"><pre
            class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">proj()</span> <span class="kw">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">cd</span> ~/dev/<span class="st">&quot;</span><span class="va">$1</span><span class="st">&quot;</span> <span class="kw">&amp;&amp;</span> <span class="ex">tmux</span> new-session <span class="at">-d</span> <span class="at">-s</span> <span class="st">&quot;</span><span class="va">$1</span><span class="st">&quot;</span> <span class="kw">&amp;&amp;</span> <span class="ex">tmux</span> attach <span class="at">-t</span> <span class="st">&quot;</span><span class="va">$1</span><span class="st">&quot;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">}</span></span></code></pre></div>
            <p>Now <code>proj myapp</code> creates a new tmux session,
            navigates to your project directory, and drops you into a
            focused workspace. One command for a complete context
            switch.</p>
            <p>In general, the goal isn’t to memorize every flag and
            option. The goal is to configure your environment once<a
            href="#fn2" class="footnote-ref" id="fnref2"
            role="doc-noteref"><sup>2</sup></a>, correctly, so that the
            most efficient way to do something is also the most natural
            way.</p>
            <p><strong>[DICLAIMER]</strong> There is something worth
            mentioning. And it applies to all of the things I recommend
            in this post and beyond. You’ll read all of this, and you’ll
            be excited to jam in a ton of features that look cool and
            sound useful. However, you must have balance! Add too many
            features and you drag out shell start up time. The best way
            to never have to worry about start up time is to take the
            features you absolutely need, and discard the rest. Just
            because something is flashy doesn’t mean you <em>need</em>
            it.</p>
            <h2 id="essential-command-line-tools">Essential Command Line
            Tools</h2>
            <p>Now that your shell is properly configured (and your
            terminal is actually a usable size), it’s worth talking
            about the tools that will do the heavy lifting in your
            day-to-day life.</p>
            <p>The Unix philosophy got a lot of things right: small
            programs that do one thing well, and do it really well. The
            core utilities—<code>grep</code>, <code>sed</code>,
            <code>awk</code>, <code>find</code>—have been around for
            decades because they work. But here’s the thing: we can do
            better.</p>
            <p>You should learn the classics first. Understand that
            <code>grep</code> is for searching text, <code>find</code>
            is for locating files, and pipes (<code>|</code>) chain
            commands together. These form the backbone of command line
            productivity:</p>
            <div class="sourceCode" id="cb3"><pre
            class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">find</span> . <span class="at">-name</span> <span class="st">&quot;*.js&quot;</span> <span class="kw">|</span> <span class="fu">grep</span> <span class="at">-v</span> node_modules <span class="kw">|</span> <span class="fu">head</span> <span class="at">-10</span></span></code></pre></div>
            <p>This finds JavaScript files, excludes node_modules, and
            shows the first 10 results. It’s composable, predictable,
            and works everywhere.</p>
            <p>Eventually, upgrade to the modern alternatives. The new
            generation of command line tools takes the Unix philosophy
            and makes it faster, more user-friendly, and frankly, more
            pleasant to use:</p>
            <ul>
            <li><strong>ripgrep (<code>rg</code>)</strong> instead of
            <code>grep</code> - It’s absurdly fast and has sane
            defaults</li>
            <li><strong>fd</strong> instead of <code>find</code> -
            Simple syntax that actually makes sense</li>
            <li><strong>bat</strong> instead of <code>cat</code> -
            Syntax highlighting and line numbers built-in</li>
            <li><strong>exa</strong> instead of <code>ls</code> - Better
            formatting and git integration</li>
            </ul>
            <p>Here’s the same search with modern tools:</p>
            <div class="sourceCode" id="cb4"><pre
            class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ex">fd</span> <span class="st">&quot;\.js$&quot;</span> <span class="kw">|</span> <span class="ex">rg</span> <span class="at">-v</span> node_modules <span class="kw">|</span> <span class="fu">head</span> <span class="at">-10</span></span></code></pre></div>
            <p>Cleaner, faster, and the output actually looks good.</p>
            <p><strong>fzf</strong> (fuzzy finding) is fucking amazing.
            Install it, configure it, and watch your productivity
            skyrocket. It turns any list into an interactive, searchable
            interface. Want to find a file? <code>Ctrl+T</code>. Want to
            search command history? <code>Ctrl+R</code>. Want to kill a
            process?
            <code>ps aux | fzf | awk '{print $2}' | xargs kill</code>.</p>
            <p>All of these are neat individual tools. But they’re also
            utilities which, when composed together, allow you to do
            literally anything. Master pipes, redirection, and command
            substitution, and you can create powerful one-liners that
            solve complex problems in seconds.</p>
            <p>Don’t try to learn everything at once. Pick one modern
            tool, use it until it becomes muscle memory, then add the
            next one. The compound effect is what matters here.</p>
            <h2 id="terminal-multiplexers">Terminal Multiplexers</h2>
            <p>When you dedicate a lot of time in your terminal, it
            quickly becomes apparent how cumbersome it can get. When web
            browsing, you can create new windows and swiftly
            <code>ALT-TAB</code> between them. Within a window, you can
            switch between tabs with <code>CMD/CTRL-0..9</code> You can
            bookmark and return to your workspace at will. There’s a
            parallel here—you can open multiple terminal windows, and
            that works… sort of. But you still have to reopen everything
            with each new terminal instance.</p>
            <p>I found something much better. It does exactly what I
            want. It’s called <a
            href="https://tmuxcheatsheet.com/how-to-install-tmux/">tmux</a>,
            a terminal multiplexer.</p>
            <p>A terminal multiplexer is a program that transparently
            “sits between” your active terminal connection and K spawned
            terminal sessions. With tmux, you can start a session, open
            new windows, and hotkey between them. You can detach and
            reattach to sessions at will. In other words, you can set a
            session aside and return to it later, and everything will be
            exactly how you left it.</p>
            <p>With a plugin, these sessions can even persist across
            system restarts.</p>
            <p>Tmux is incredibly useful, and if you plan on doing
            <strong>any</strong> serious work in the terminal, it will
            save you a huge amount of time. Install it and never look
            back.</p>
            <p>You can create a new session with
            <code>tmux new -s session_name</code>, detach with
            <code>CTRL-B D</code>, and reattach with
            <code>tmux attach -t session_name</code>. Some other useful
            commands include:</p>
            <pre><code>tmux ls                             # list sessions
tmux kill-session -t session_name   # kill a session
tmux kill-server                    # kill the server
tmux a -t session_name              # attach to a session
tmux a                              # attach to the last session</code></pre>
            <h3 id="customization">Customization</h3>
            <p>When you start Tmux, the program looks for a .dotfile<a
            href="#fn3" class="footnote-ref" id="fnref3"
            role="doc-noteref"><sup>3</sup></a> at
            <code>~/.tmux.conf</code>. This plain-text file is where you
            can configure and “rice out”<a href="#fn4"
            class="footnote-ref" id="fnref4"
            role="doc-noteref"><sup>4</sup></a> your multiplexer. You’ll
            begin by adding a plugin manager, <a
            href="https://github.com/tmux-plugins/tpm">tpm</a>, and then
            use it to load a few plugins and a nice theme<a href="#fn5"
            class="footnote-ref" id="fnref5"
            role="doc-noteref"><sup>5</sup></a>.</p>
            <h3 id="alternatively-wezterm">Alternatively: WezTerm</h3>
            <p>If Tmux doesn’t tickle your fancy, try <a
            href="https://wezterm.org/index.html">WezTerm</a>, a
            cross-platform terminal emulator and multiplexer implemented
            in Rust. It’s config is in Lua. This is what I use right
            now, and it’s very nice. But make sure to build familiarity
            in Tmux too, for when SSH’d into servers, TMUX is your only
            real option.</p>
            <h2 id="text-editors-vim-and-beyond">Text Editors: Vim and
            Beyond</h2>
            <p>Once you have your shell configured and your multiplexer
            managing your sessions, it’s time to talk about the heart of
            your development workflow: your text editor.</p>
            <p>I’ve been using Vim for about three years. When we
            mention Vim, it’s usually in one of two contexts:
            <code>vim</code> (the program), or Vim Motions.</p>
            <p><strong>Vim Motions</strong> are the keybindings that
            allow you to move around the text. They are the most
            important part of Vim. Everyone should use Vim Motions. They
            are extremely efficient. They’re available on all text
            editors and IDEs. <strong>Vim</strong>, by contrast, is a
            highly configurable, extensible text editor built to make
            creating and changing any kind of text very efficient.</p>
            <h3 id="vim-motions">Vim Motions</h3>
            <p>There is only one type of grammar in Vim: Vim Motions.
            It’s a language that allows you to move around the text.</p>
            <p>Here’s a quick reference of some common Vim Motions:</p>
            <table>
            <colgroup>
            <col style="width: 11%" />
            <col style="width: 10%" />
            <col style="width: 77%" />
            </colgroup>
            <thead>
            <tr class="header">
            <th>Category</th>
            <th>Command</th>
            <th>Description</th>
            </tr>
            </thead>
            <tbody>
            <tr class="odd">
            <td>motion</td>
            <td>h</td>
            <td>Left</td>
            </tr>
            <tr class="even">
            <td></td>
            <td>j</td>
            <td>Down</td>
            </tr>
            <tr class="odd">
            <td></td>
            <td>k</td>
            <td>Up</td>
            </tr>
            <tr class="even">
            <td></td>
            <td>l</td>
            <td>Right</td>
            </tr>
            <tr class="odd">
            <td></td>
            <td>w</td>
            <td>Move forward to the beginning of the next word</td>
            </tr>
            <tr class="even">
            <td></td>
            <td>}</td>
            <td>Jump to the next paragraph</td>
            </tr>
            <tr class="odd">
            <td></td>
            <td>$</td>
            <td>Go to the end of the line</td>
            </tr>
            <tr class="even">
            <td>operator</td>
            <td>y</td>
            <td>Yank text (copy)</td>
            </tr>
            <tr class="odd">
            <td></td>
            <td>d</td>
            <td>Delete text and save to register</td>
            </tr>
            <tr class="even">
            <td></td>
            <td>c</td>
            <td>Delete text, save to register, and start insert
            mode</td>
            </tr>
            </tbody>
            </table>
            <p>More generally, the syntax looks like:
            <code>[count] + &lt;operator&gt; + (motion)</code>. For
            example, <code>3dw</code> would delete three words.
            <code>2yy</code> would yank two lines. <code>c$</code> would
            delete to the end of the line and start insert mode.
            <code>dap</code> would delete a paragraph. <code>vi(y</code>
            would select within the nearest set of <code>{ }</code> and
            yank the contents. It’s wonderfully composable.</p>
            <p>Notice how, for some, the phonetic sound of the command
            matches the action. <code>d</code> for delete,
            <code>y</code> for yank, <code>c</code> for change. This is
            a mnemonic device to help you remember the commands. Delete
            a paragraph? <code>dap</code>. Change a word?
            <code>caw</code>.</p>
            <h3 id="vim-the-program">Vim (The Program)</h3>
            <p>Vim, by contrast, is a highly configurable, extensible
            text editor in your terminal built to make creating and
            changing any kind of text very efficient.</p>
            <p>My friend <a href="https://scharenbroch.dev/">Lucas</a>
            rather aptly put:</p>
            <blockquote>
            <p>Vim is the bliss of Ctrl C/V but applied to every facet
            of the editor.</p>
            </blockquote>
            <p>I think that’s a really good way to describe it. Vim
            recognizes and eliminates the vast majority of typing
            inefficiencies. The result is blazingly fast precision, and
            a workflow that feels like a dance.</p>
            <p>Lucas wrote a list of <a
            href="https://scharenbroch.dev/blog/vim-bindings/">every
            single Vim binding he knows</a>. It’s substantial, but you
            never learn them all at the same time. Start with a subset,
            and gradually expand it.</p>
            <p>A contention I often receive is, “well, how do I debug in
            Vim?” You don’t. You have separate programs<a href="#fn6"
            class="footnote-ref" id="fnref6"
            role="doc-noteref"><sup>6</sup></a>. Each program is good at
            what it does. If you build a hodgepodge of functionality you
            end up with an IDE and that’s precisely what I’m trying to
            escape.</p>
            <p>I will concede, however, that Vim is not beginner
            friendly. There’s a learning curve. However, Vim is
            exceptionally user friendly<a href="#fn7"
            class="footnote-ref" id="fnref7"
            role="doc-noteref"><sup>7</sup></a>. Once you get the hang
            of things, and it clicks, it’s really, really fun to use.
            Here’s <a href="https://scharenbroch.dev/blog/vim/">Lucas’
            argument</a> in favor of Vim.</p>
            <p>A lot of people recommend learning Vim Motions on your
            current editor first before switching to Vim full time. I
            didn’t do this, but it’s the path most people take. I’m a
            bit weird. I like to cold turkey and learn things from the
            ground up right away. But that’s a digression.</p>
            <h3 id="neovim">Neovim</h3>
            <p>Vim’s extensibility takes it to the next level. Enter:
            Neovim. Taken from the Neovim Charter:</p>
            <blockquote>
            <p>Neovim is a refactor, and sometimes redactor, in the
            tradition of Vim. It is not a rewrite but a continuation and
            extension of Vim. Many clones and derivatives exist, some
            very clever—but none are Vim. Neovim is built for users who
            want the good parts of Vim, and more.</p>
            </blockquote>
            <p>Neovim’s component-like plugin structure allows you to
            drop in and take out functionality easily. You can bring in
            an <a
            href="https://github.com/neovim/nvim-lspconfig">LSP</a>, <a
            href="https://github.com/hrsh7th/nvim-cmp">completions</a>,
            <a href="https://github.com/L3MON4D3/LuaSnip">snippets</a>,
            <a href="https://github.com/tpope/vim-fugitive">git</a>, and
            <a
            href="https://github.com/nvim-neotest/neotest">testing</a>
            infrastructure. You can get new things too: <a
            href="https://github.com/nvim-treesitter">Treesitter</a>, <a
            href="https://github.com/nvim-telescope/telescope.nvim">Telescope</a>
            FZF (fuzzy finding), Scoped grep string searches, and <a
            href="https://github.com/ThePrimeagen/harpoon/tree/harpoon2">Harpoon</a>
            anchor points to jump around.</p>
            <p>What’s more, since YOU configure Neovim, you’ll come away
            with a complete understanding of how each tool works, and
            how they interact with one another to create a complete
            ecosystem. By contrast, other editors and IDEs abstract this
            away.</p>
            <p>I know I just said a lot of words. The takeaway is this:
            With Neovim, you know exactly why everything works the way
            it does, and you can make it work exactly the way you want
            it to. The possibilities are, in fact, endless.</p>
            <p>Want functionality but there’s no plugin for it? Your
            config is in Lua and everything in Lua is easy. Make it,
            maintain it, push it to the Neovim community! The Neovim
            community is vibrant and full of passionate creators and
            maintainers who work hard to support the editor they
            love.</p>
            <h2 id="workflow-automation">Workflow Automation</h2>
            <p>Now that you’ve been introduced to the core tools—shell,
            command line utilities, multiplexers, and editors—it’s time
            to tie them all together into automated workflows that
            eliminate repetitive tasks you do every single day.</p>
            <p>Shell scripts are your friend. A commonly accepted
            general rule: if you find yourself typing the same sequence
            of commands more than twice, write a script. I don’t care if
            it’s just three lines—write it anyway. Here’s one I use
            constantly:</p>
            <div class="sourceCode" id="cb6"><pre
            class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/bin/bash</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co"># backup.sh - my quick project backup</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="fu">tar</span> <span class="at">-czf</span> ~/backups/<span class="va">$(</span><span class="fu">basename</span> <span class="va">$(</span><span class="bu">pwd</span><span class="va">))</span>-<span class="va">$(</span><span class="fu">date</span> +%Y%m%d<span class="va">)</span>.tar.gz .</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">&quot;Backed up </span><span class="va">$(</span><span class="fu">basename</span> <span class="va">$(</span><span class="bu">pwd</span><span class="va">))</span><span class="st"> to ~/backups/&quot;</span></span></code></pre></div>
            <p>Throw it in your <code>PATH</code>, make it executable,
            and now <code>backup</code> creates a timestamped archive of
            your current project. Takes 30 seconds to write, saves hours
            over time.</p>
            <h3 id="making-scripts-global">Making Scripts Global</h3>
            <p>Before we go further, let’s talk about where to put these
            scripts so they actually work from anywhere. You don’t want
            to type <code>./backup.sh</code> every time—you want to type
            <code>backup</code> and have it just work.</p>
            <p>Create a directory for your personal scripts:</p>
            <div class="sourceCode" id="cb7"><pre
            class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mkdir</span> <span class="at">-p</span> ~/.local/bin</span></code></pre></div>
            <p>Add this directory to your PATH by putting this in your
            shell config (<code>.zshrc</code>, <code>.bashrc</code>,
            etc.):</p>
            <div class="sourceCode" id="cb8"><pre
            class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="bu">export</span> <span class="va">PATH</span><span class="op">=</span><span class="st">&quot;</span><span class="va">$HOME</span><span class="st">/.local/bin:</span><span class="va">$PATH</span><span class="st">&quot;</span></span></code></pre></div>
            <p>Now, for any script you write, make it executable and <a
            href="https://en.wikipedia.org/wiki/Symbolic_link">symlink</a>
            it to your bin directory:</p>
            <div class="sourceCode" id="cb9"><pre
            class="sourceCode bash"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">chmod</span> +x backup.sh</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="fu">ln</span> <span class="at">-s</span> /full/path/to/backup.sh ~/.local/bin/backup</span></code></pre></div>
            <p>Notice I dropped the <code>.sh</code> extension in the
            symlink. Global commands shouldn’t look like scripts.
            Instead, they should look like built-in commands. When you
            type <code>backup</code>, nobody needs to know it’s actually
            a shell script living somewhere else.</p>
            <p>This approach is cleaner than copying scripts around
            because you can edit the original file and the changes are
            immediately available everywhere. Your scripts live in your
            projects or dotfiles repo, but they’re accessible from any
            directory.</p>
            <p>On that note, dotfiles management is non-negotiable: your
            shell config, your editor settings, your aliases—all of it
            should be in version control. When you get a new machine or
            mess something up, you want to be back to your perfect setup
            in minutes, not hours.</p>
            <p>So, create a dotfiles repository, use symlinks or a tool
            like <a href="https://www.gnu.org/software/stow/">GNU
            Stow</a>, and never lose your configuration again. My rule:
            if I spend more than 15 minutes customizing something, it
            goes in the dotfiles repo immediately.</p>
            <p>Project-specific automation is nice too. Consider
            creating a <code>.envrc</code> files (if you use <a
            href="https://direnv.net/">direnv</a>) or simple shell
            scripts that set up your environment automatically:</p>
            <div class="sourceCode" id="cb10"><pre
            class="sourceCode bash"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># dev.sh - example project setup script</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="bu">export</span> <span class="va">DATABASE_URL</span><span class="op">=</span><span class="st">&quot;postgresql://localhost/myapp_dev&quot;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="bu">export</span> <span class="va">NODE_ENV</span><span class="op">=</span><span class="st">&quot;development&quot;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">[</span> <span class="ot">!</span> <span class="ot">-d</span> <span class="st">&quot;node_modules&quot;</span> <span class="bu">]</span><span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">echo</span> <span class="st">&quot;installing deps...&quot;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="ex">npm</span> install</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="cf">fi</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">&quot;env is prepared&quot;</span></span></code></pre></div>
            <p>In this example, every project now has its own
            <code>./dev.sh</code> that gets you from cold start to
            ready-to-code in one command.</p>
            <p>Again, we return to the idea of eliminating friction. We
            couldn’t possibly make scripts for every scenario (nor
            should we). Rather, we hasten those little context switches,
            those “wait, how do I do this again?” moments, those
            repetitive setup tasks. Eliminate them, and you’ll find
            yourself in flow state more often and frustrated less.</p>
            <h2 id="development-integration">Development
            Integration</h2>
            <p>The final layer builds upon everything we’ve covered thus
            far, integrating your command line workflow with the broader
            development ecosystem: version control, build systems,
            testing frameworks, and deployment pipelines.</p>
            <p>This is where your terminal setup stops being just a
            collection of tools and becomes something more. You probably
            don’t need all of these, but here are a few ideas:</p>
            <p>Configure aliases that match your actual workflow:</p>
            <div class="sourceCode" id="cb11"><pre
            class="sourceCode bash"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> config <span class="at">--global</span> alias.co checkout</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> config <span class="at">--global</span> alias.br branch</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> config <span class="at">--global</span> alias.st status</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> config <span class="at">--global</span> alias.unstage <span class="st">&#39;reset HEAD --&#39;</span></span></code></pre></div>
            <p>Create functions that handle entire workflows:</p>
            <div class="sourceCode" id="cb12"><pre
            class="sourceCode bash"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># quick commit with message</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="fu">qc()</span> <span class="kw">{</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">git</span> add . <span class="kw">&amp;&amp;</span> <span class="fu">git</span> commit <span class="at">-m</span> <span class="st">&quot;</span><span class="va">$1</span><span class="st">&quot;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="kw">}</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="co"># make and switch to new branch</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="fu">nb()</span> <span class="kw">{</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">git</span> checkout <span class="at">-b</span> <span class="st">&quot;</span><span class="va">$1</span><span class="st">&quot;</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="kw">}</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="co"># push current branch and set upstream</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a><span class="fu">pushup()</span> <span class="kw">{</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">git</span> push <span class="at">-u</span> origin <span class="va">$(</span><span class="fu">git</span> branch <span class="at">--show-current</span><span class="va">)</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="kw">}</span></span></code></pre></div>
            <p>Now <code>qc "Fix login bug"</code> handles your entire
            commit process, and <code>nb feature/new-auth</code> creates
            and switches to a new branch in one command.</p>
            <p>Create project-agnostic scripts that handle the
            complexity of build tools:</p>
            <div class="sourceCode" id="cb13"><pre
            class="sourceCode bash"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># dev.sh - universal dev server</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">[</span> <span class="ot">-f</span> <span class="st">&quot;package.json&quot;</span> <span class="bu">]</span><span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="ex">npm</span> run dev <span class="dv">2</span><span class="op">&gt;</span>/dev/null <span class="kw">||</span> <span class="ex">npm</span> start</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="cf">elif</span> <span class="bu">[</span> <span class="ot">-f</span> <span class="st">&quot;Cargo.toml&quot;</span> <span class="bu">]</span><span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="ex">cargo</span> run</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="cf">elif</span> <span class="bu">[</span> <span class="ot">-f</span> <span class="st">&quot;Makefile&quot;</span> <span class="bu">]</span><span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">make</span> dev <span class="kw">||</span> <span class="fu">make</span> run</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="cf">fi</span></span></code></pre></div>
            <p>Put this in your PATH, and now <code>dev</code> starts
            the right development server regardless of project type.</p>
            <p>The best test suite is the one you actually run:</p>
            <div class="sourceCode" id="cb14"><pre
            class="sourceCode bash"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># t.sh - a smart test runner</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">[</span> <span class="ot">-f</span> <span class="st">&quot;package.json&quot;</span> <span class="bu">]</span> <span class="kw">&amp;&amp;</span> <span class="fu">grep</span> <span class="at">-q</span> <span class="st">&quot;test&quot;</span> package.json<span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="ex">npm</span> test</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="cf">elif</span> <span class="bu">[</span> <span class="ot">-f</span> <span class="st">&quot;Cargo.toml&quot;</span> <span class="bu">]</span><span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="ex">cargo</span> test</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="cf">elif</span> <span class="bu">[</span> <span class="ot">-f</span> <span class="st">&quot;Makefile&quot;</span> <span class="bu">]</span> <span class="kw">&amp;&amp;</span> <span class="fu">grep</span> <span class="at">-q</span> <span class="st">&quot;test:&quot;</span> Makefile<span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">make</span> test</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="cf">fi</span></span></code></pre></div>
            <p>Make environment switching seamless with <a
            href="https://direnv.net/">direnv</a>, which automatically
            loads environment variables when you enter a project
            directory:</p>
            <div class="sourceCode" id="cb15"><pre
            class="sourceCode bash"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># .envrc in project root</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="bu">export</span> <span class="va">DATABASE_URL</span><span class="op">=</span><span class="st">&quot;postgresql://localhost/myapp_dev&quot;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="bu">export</span> <span class="va">NODE_ENV</span><span class="op">=</span><span class="st">&quot;development&quot;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="ex">use</span> node 18.17.0</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="ex">PATH_add</span> ./node_modules/.bin</span></code></pre></div>
            <p>Now every time you <code>cd</code> into this project,
            your environment is automatically configured.</p>
            <p>Create deployment scripts that handle the entire
            pipeline:</p>
            <div class="sourceCode" id="cb16"><pre
            class="sourceCode bash"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># deploy.sh</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="co">#!/bin/bash</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="bu">set</span> <span class="at">-e</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">&quot;starting deployment...&quot;</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="ex">npm</span> test</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="ex">npm</span> run build</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="va">current_branch</span><span class="op">=</span><span class="va">$(</span><span class="fu">git</span> branch <span class="at">--show-current</span><span class="va">)</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">[</span> <span class="st">&quot;</span><span class="va">$current_branch</span><span class="st">&quot;</span> <span class="ot">=</span> <span class="st">&quot;main&quot;</span> <span class="bu">]</span><span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">git</span> push heroku main</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">echo</span> <span class="st">&quot;deployed to prod&quot;</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">echo</span> <span class="st">&quot;oops! can only deploy from main branch&quot;</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">exit</span> 1</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a><span class="cf">fi</span></span></code></pre></div>
            <p>Create universal commands that work regardless of package
            manager for consistent package management:</p>
            <div class="sourceCode" id="cb17"><pre
            class="sourceCode bash"><code class="sourceCode bash"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># install.sh</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">[</span> <span class="ot">-f</span> <span class="st">&quot;package-lock.json&quot;</span> <span class="bu">]</span><span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="ex">npm</span> install</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="cf">elif</span> <span class="bu">[</span> <span class="ot">-f</span> <span class="st">&quot;yarn.lock&quot;</span> <span class="bu">]</span><span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="ex">yarn</span> install</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="cf">elif</span> <span class="bu">[</span> <span class="ot">-f</span> <span class="st">&quot;Cargo.toml&quot;</span> <span class="bu">]</span><span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span class="ex">cargo</span> build</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="cf">elif</span> <span class="bu">[</span> <span class="ot">-f</span> <span class="st">&quot;requirements.txt&quot;</span> <span class="bu">]</span><span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    <span class="ex">pip</span> install <span class="at">-r</span> requirements.txt</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="cf">fi</span></span></code></pre></div>
            <p>Importantly, these optimizations <em>compound</em>. When
            switching between projects is frictionless, when tests run
            automatically, when deployment is one command, you spend
            less time context switching. Every project feels familiar
            because the interface is consistent, even when the
            underlying technology stack is different.</p>
            <h2 id="mental-model">Mental Model</h2>
            <p>Now that we’ve walked through each component, here’s how
            to think about the complete picture of terminal tooling:</p>
            <p>Each layer builds upon the previous ones, creating a
            compound effect where mastering multiple aspects leads to
            exponential productivity gains rather than linear
            improvements. Your shell provides the foundation, command
            line tools give you power, multiplexers organize your
            workspace, editors let you manipulate text efficiently,
            automation eliminates repetition, and development
            integration connects everything to your broader
            workflow.</p>
            <h2 id="wrapping-up">Wrapping up</h2>
            <p>In exploring the minimalist, keyboard-centric workflow of
            command line tools and editors like Vim and Neovim, we
            uncover a significant truth about productivity in software
            development: simplicity and customization can profoundly
            enhance efficiency. By adopting tools such as Tmux and Vim,
            developers are equipped to create a highly personalized
            development environment. This environment not only
            streamlines tasks but also keeps the focus on coding,
            reducing distractions inherent in more complex IDEs.
            Embracing these tools may involve a learning curve, but the
            long-term gains in speed, understanding, and adaptability
            make this investment worthwhile.</p>
            <p>For those willing to explore these command line utilities
            and text editors, the payoff is a more intuitive and
            efficient coding experience that aligns perfectly with the
            unique needs of each developer.</p>
            <p>And as always, remember: <strong><em>Life is like Vim:
            There are a lot of shortcuts and you should take
            them.</em></strong></p>
            <h2 id="footnotes">Footnotes</h2>
            <aside id="footnotes"
            class="footnotes footnotes-end-of-document"
            role="doc-endnotes">
            <hr />
            <ol>
            <li id="fn1"><p>The objective is reducing the most common
            sources of friction in your everyday routine. Instead of
            trying to find a quicker way to do everything under the sun,
            reflect on your routines and make those processes swifter.<a
            href="#fnref1" class="footnote-back"
            role="doc-backlink">↩︎</a></p></li>
            <li id="fn2"><p>If you don’t want to set up your shell
            yourself, here is an <a
            href="https://github.com/jo%20tyGill/ezsh">elegant
            script</a>.<a href="#fnref2" class="footnote-back"
            role="doc-backlink">↩︎</a></p></li>
            <li id="fn3"><p>Many programs store their configuration
            files in plain text files. These are usually (but not
            always) in your <code>~</code> or <code>~/.config/~</code>
            directories. Dotfiles are configuration files for various
            programs. What sets them apart from regular files and
            directories is their prefix: a dot (<code>.</code>). Note:
            On Unix based systems, dotfiles are hidden by the OS by
            default.<a href="#fnref3" class="footnote-back"
            role="doc-backlink">↩︎</a></p></li>
            <li id="fn4"><p>Ricing is a process in which one customizes
            their OS or programs to improve the aesthetics or refine
            their workflow.<a href="#fnref4" class="footnote-back"
            role="doc-backlink">↩︎</a></p></li>
            <li id="fn5"><p>In earlier drafts, I recommended <a
            href="https://github.com/catppuccin/tmux">catppuccin</a>
            (mocha) or <a
            href="https://github.com/folke/tokyonight.nvim">tokyonight</a>
            by Folke; these days, I like a simpler, higher contrast
            theme like one of the built vim defaults, elflord.<a
            href="#fnref5" class="footnote-back"
            role="doc-backlink">↩︎</a></p></li>
            <li id="fn6"><p>In the case of debugging, one might opt for
            <code>gdb</code>, the browser, or the python debugger,
            etc.<a href="#fnref6" class="footnote-back"
            role="doc-backlink">↩︎</a></p></li>
            <li id="fn7"><p>I’m paraphrasing <a
            href="https://github.com/ThePrimeagen">ThePrimeagen</a>, a
            Neovim enjoyer and popular streamer.<a href="#fnref7"
            class="footnote-back" role="doc-backlink">↩︎</a></p></li>
            </ol>
            </aside>
        </article>
    </div>
    <footer>
        <p>© 2025 salm.dev</p>
    </footer>
</body>
</html>
