<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="icon" type="image/svg+xml" href="/assets/favicon.svg">
<style>
@font-face {
    font-family: 'charter';
    font-style: normal;
    font-weight: normal;
    font-stretch: normal;
    font-display: swap;
    src: url('/assets/fonts/charter_regular.woff2') format('woff2');
}

@font-face {
    font-family: 'charter';
    font-style: italic;
    font-weight: normal;
    font-stretch: normal;
    font-display: swap;
    src: url('/assets/fonts/charter_italic.woff2') format('woff2');
}

@font-face {
    font-family: 'charter';
    font-style: normal;
    font-weight: bold;
    font-stretch: normal;
    font-display: swap;
    src: url('/assets/fonts/charter_bold.woff2') format('woff2');
}

@font-face {
    font-family: 'charter';
    font-style: italic;
    font-weight: bold;
    font-stretch: normal;
    font-display: swap;
    src: url('/assets/fonts/charter_bold_italic.woff2') format('woff2');
}

@font-face {
    font-family: 'firacode';
    src: url('/assets/fonts/firacode_regular.woff2') format('woff2');
    font-weight: normal;
    font-style: normal;
    font-display: swap;
}

:root {
    --bg-color: #ffffff;
    --text-color: #2a2a2a;
    --text-secondary: #666666;
    --link-color: #0066cc;
    --border-color: #eee;
    --code-bg: #f5f5f5;

    --syntax-keyword: #954121;
    --syntax-type: #b00040;
    --syntax-number: #666666;
    --syntax-string: #219161;
    --syntax-prompt: #000080;
    --syntax-output: #808080;
    --syntax-comment: #808080;

    --font-family-body: charter, "Times New Roman";
    --font-family-code: firacode, monospace;
    --font-size-base: 1rem;
    --font-size-small: 0.9rem;
    --line-height: 1.6;
    --line-height-tight: 1.1;
    --line-height-heading: 1.2;

    --spacing-tiny: 0.25rem;
    --spacing-small: 0.5rem;
    --spacing-medium: 1rem;
    --spacing-large: 1.5rem;
    --spacing-xl: 2rem;
    --spacing-huge: 3rem;

    --max-width: 850px;
    --breakpoint-mobile: 576px;
    --breakpoint-tablet: 768px;

    --transition: 0.3s ease;
    --border-standard: 1px solid var(--border-color);
    --border-emphasis: 2px solid var(--text-color);
    --heading-margin: var(--spacing-large) 0 var(--spacing-medium);
}

@media (prefers-color-scheme: dark) {
    :root {
        --bg-color: #1a1a1a;
        --text-color: #e0e0e0;
        --text-secondary: #888888;
        --link-color: #66aaff;
        --border-color: #333;
        --code-bg: #2a2a2a;

        --syntax-keyword: #af5a54;
        --syntax-type: #b64343;
        --syntax-number: #688ec8;
        --syntax-string: #718e72;
        --syntax-prompt: #8a6ab1;
        --syntax-output: #868686;
        --syntax-comment: #868686;
    }

    header.main-nav img[src="/assets/logo-black.svg"] {
        content: url("/assets/logo-white.svg");
    }

    .post-link[data-description]:hover::after {
        background-color: #2a2a2a;
        border: 1px solid #555;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }
}

* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    font-family: var(--font-family-body);
    font-size: var(--font-size-base);
    line-height: var(--line-height);
    max-width: var(--max-width);
    color: var(--text-color);
    background-color: var(--bg-color);
    margin: 0 auto;
    padding: 20px;
    transition: background-color var(--transition), color var(--transition);
}

h1,
h2,
h3,
h4,
h5,
h6 {
    font-family: var(--font-family-body);
    margin: var(--heading-margin);
    line-height: var(--line-height-heading);
    color: var(--text-color);
    font-variant: small-caps;
    text-decoration: none;
}

h1 {
    font-size: 2.25rem;
    text-align: center;
    margin-top: var(--spacing-small);
}

h2 {
    font-size: 1.75rem;
    margin-top: var(--spacing-xl);
    position: relative;
    padding-bottom: 2px;
}

h2::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 1px;
    background-color: var(--text-color);
}

h3 {
    font-size: 1.5rem;
    position: relative;
    padding-bottom: 2px;
}

h3::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 1px;
    background-image: radial-gradient(circle, var(--text-color) 0.5px, transparent 0.5px);
    background-size: 3px 1px;
    background-repeat: repeat-x;
}

h4 {
    font-size: 1.25rem;
}

.year-heading {
    margin-top: var(--spacing-large);
    margin-bottom: var(--spacing-medium);
}

.year-heading.first-year {
    margin-top: var(--spacing-small);
}

.tags-heading {
    margin: 0;
}

p {
    margin-bottom: var(--spacing-medium);
}

small {
    font-size: 0.875em;
}

a {
    color: var(--link-color);
    text-decoration: underline;
}

ul,
ol {
    margin: var(--spacing-medium) 0;
    padding-left: var(--spacing-xl);
}

li {
    margin-bottom: var(--spacing-tiny);
}

h4.year-heading+ul {
    margin-top: 0;
}

code {
    font-family: var(--font-family-code);
    background-color: var(--code-bg);
    color: var(--text-color);
    padding: 0.15rem 0.3rem;
    border-radius: 0;
    border: var(--border-standard);
    font-size: var(--font-size-small);
    white-space: pre-wrap;
    word-wrap: break-word;
}

pre {
    background-color: var(--code-bg);
    padding: var(--spacing-medium);
    border-radius: 0;
    border: var(--border-standard);
    overflow-x: auto;
    margin: var(--spacing-medium) 0;
    white-space: pre;
}

pre code {
    padding: 0;
    background-color: transparent;
    border: none;
    white-space: pre;
    overflow-x: visible;
}

.o,
.k,
.kc,
.kd,
.kn,
.nb,
.cf,
.kw,
.op {
    color: var(--syntax-keyword);
}

.kt,
.dt {
    color: var(--syntax-type);
}

.m,
.mf,
.mh,
.mi,
.mo {
    color: var(--syntax-number);
}

.s,
.sc,
.st {
    color: var(--syntax-string);
}

.gp {
    color: var(--syntax-prompt);
}

.go {
    color: var(--syntax-output);
}

.c1,
.co {
    color: var(--syntax-comment);
}

/* tables */
table {
    width: 100%;
    border-collapse: collapse;
    margin: var(--spacing-medium) 0;
    font-size: var(--font-size-base);
}

th,
td {
    padding: var(--spacing-small) var(--spacing-medium);
    text-align: left;
    border-bottom: var(--border-standard);
}

th {
    font-weight: bold;
    color: var(--text-color);
    border-bottom: var(--border-emphasis);
}

/* quotes */
blockquote {
    margin: var(--spacing-large) 0;
    padding: var(--spacing-medium);
    background-color: var(--code-bg);
    color: var(--text-color);
    font-style: normal;
    border: var(--border-standard);
    border-radius: 0;
    position: relative;
}

blockquote p {
    margin-bottom: var(--spacing-small);
}

blockquote p:last-child {
    margin-bottom: 0;
}

blockquote blockquote {
    background-color: #e8e8e8;
    color: var(--text-color);
    border-color: #e8e8e8;
}

@media (prefers-color-scheme: dark) {
    blockquote blockquote {
        background-color: #777777;
        border-color: #777777;
    }
}

.quote-container {
    padding: var(--spacing-large);
    margin: var(--spacing-large) 0;
    position: relative;
    display: flex;
    align-items: center;
    gap: var(--spacing-medium);
}

.quote-container::before {
    content: '“';
    font-family: var(--font-family-body);
    font-size: 4rem;
    color: var(--text-secondary);
    opacity: 0.4;
    line-height: 1;
    font-weight: normal;
    flex-shrink: 0;
}

.quote-container::after {
    content: '”';
    font-family: var(--font-family-body);
    font-size: 4rem;
    color: var(--text-secondary);
    opacity: 0.4;
    line-height: 1;
    font-weight: normal;
    flex-shrink: 0;
}

.quote-content {
    flex: 1;
    text-align: center;
}

.quote-text {
    font-size: 1.25rem;
    line-height: 1.4;
    color: var(--text-color);
    font-style: italic;
    margin: 0 0 var(--spacing-small) 0;
}

.quote-author {
    font-size: 1rem;
    font-weight: normal;
    color: var(--text-color);
    font-variant: small-caps;
}

/* media */
img {
    max-width: 100%;
    height: auto;
    display: block;
    margin: var(--spacing-small) var(--spacing-tiny);
}

figure {
    margin: 0;
    text-align: center;
}

figcaption {
    font-size: var(--font-size-small);
    margin-top: 5px;
    font-style: italic;
    color: var(--text-secondary);
}

/* layout pieces */
header {
    margin-bottom: var(--spacing-medium);
}

footer {
    margin-top: var(--spacing-xl);
    padding-top: var(--spacing-medium);
    text-align: center;
    font-size: var(--font-size-small);
    color: var(--text-secondary);
    border-top: var(--border-standard);
}

.footer-note {
    color: var(--text-secondary);
    font-size: var(--font-size-small);
    font-style: italic;
    margin-bottom: var(--spacing-small);
}

/* nav */
header.main-nav {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-bottom: var(--spacing-large);
}

header.main-nav img {
    margin-bottom: 15px;
    margin-right: 0;
}

header.main-nav nav {
    width: 100%;
    overflow-x: auto;
}

/* post */
.description {
    text-align: center;
    font-style: italic;
    margin: var(--spacing-medium) 0;
    color: var(--text-secondary);
}

.description .date,
.description .updated {
    display: inline;
    font-style: normal;
    font-size: var(--font-size-small);
    color: var(--text-secondary);
}

.description .date::before {
    content: "Published ";
}

.description .updated::before {
    content: " • Updated ";
}

.description .date-info {
    display: block;
    margin-top: var(--spacing-small);
}

.post-link {
    position: relative;
    display: inline-block;
}

.post-link[data-description]:hover::after {
    content: attr(data-description);
    position: absolute;
    left: 0;
    top: 100%;
    margin-top: 5px;
    z-index: 1;
    width: 320px;
    background-color: var(--bg-color);
    padding: 10px;
    border: var(--border-standard);
    border-radius: 4px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    color: var(--text-secondary);
    font-size: var(--font-size-small);
    line-height: 1.4;
    pointer-events: none;
    transition: all var(--transition);
}

/* writing page */
.writing-layout {
    display: flex;
    gap: var(--spacing-xl);
    align-items: flex-start;
    position: relative;
}

.writing-main {
    flex: 1;
    min-width: 0;
}

.tags-section {
    position: absolute;
    right: 0;
    top: calc(var(--spacing-large) + 1rem);
    width: 250px;
    text-align: right;
    word-wrap: break-word;
    line-height: 1.8;
}

.tags-section a {
    white-space: nowrap;
    color: var(--link-color);
    opacity: 0.8;
    margin: 0 0 0.5rem 0.5rem;
    display: inline-block;
}

.tags-heading.desktop-only {
    position: absolute;
    right: 0;
    top: 0;
    margin-top: var(--spacing-small);
    line-height: var(--line-height-heading);
    font-size: 1.25rem;
    text-align: right;
}

/* special */
.buttons-layout {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
}

.buttons-container {
    display: flex;
    flex-wrap: wrap;
    gap: var(--spacing-small);
}

.button-88x31 {
    width: 88px;
    height: 31px;
    margin: 0;
}

/* about page */
.about-container {
    display: flex;
    gap: 20px;
    justify-content: space-between;
    align-items: flex-start;
}

/* footnotes */
.footnotes {
    margin-top: var(--spacing-xl);
    padding: var(--spacing-medium);
    border: var(--border-standard);
    background-color: var(--code-bg);
    border-radius: 4px;
}

.footnotes::before {
    content: "Notes";
    display: block;
    font-weight: bold;
    margin-bottom: var(--spacing-small);
    color: var(--text-color);
    font-size: var(--font-size-small);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.footnotes hr {
    display: none;
}

.footnotes ol {
    margin: 0;
    padding-left: var(--spacing-medium);
}

.footnotes li {
    margin-bottom: var(--spacing-tiny);
    font-size: var(--font-size-small);
    line-height: 1.4;
}

.footnotes p {
    margin-bottom: var(--spacing-tiny);
}

/* utiliy */
.desktop-only {
    display: block;
}

.mobile-only {
    display: none;
}

/* media queries */
@media (min-width: 576px) {
    header.main-nav {
        flex-direction: row;
        align-items: flex-start;
    }

    header.main-nav img {
        margin-right: 80px;
        margin-bottom: 0;
    }
}

@media (max-width: 768px) {
    .desktop-only {
        display: none !important;
    }

    .mobile-only {
        display: block !important;
        margin-top: var(--spacing-xl) !important;
        margin-bottom: var(--spacing-medium) !important;
        margin-left: 0 !important;
        position: static !important;
        text-align: left !important;
    }

    .quote-container {
        padding: var(--spacing-large) var(--spacing-medium);
        gap: var(--spacing-small);
    }

    .quote-container::before,
    .quote-container::after {
        font-size: 3rem;
    }

    .quote-text {
        font-size: 1.125rem;
    }

    .quote-author {
        font-size: 0.9rem;
    }

    .writing-layout {
        display: block;
    }

    .tags-section {
        position: static;
        width: 100%;
        margin-top: var(--spacing-small);
        margin-bottom: var(--spacing-xl);
        text-align: left;
    }

    .tags-section a {
        margin: 0 0.5rem 0.5rem 0;
    }
}

@media (max-width: 576px) {
    .about-container {
        flex-direction: column !important;
        align-items: center !important;
    }

    .about-container img {
        margin-bottom: 20px !important;
        order: -1 !important;
    }
}
</style>
        <title>Command Line Productivity | salm.dev</title>
                <script src="/assets/js/mathjax-config.js"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
        <link rel="preconnect" href="https://cdn.jsdelivr.net">
        <link rel="preload" href="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" as="script">
            </head>
    <body>
        <div>
            <header>
                <a href="/">home</a> / <a href="/writing/">writing</a>
            </header>
            <article>
                <h1 id="command-line-productivity">Command Line
                Productivity</h1>
                <div class="description">
                <p>I am not a fan of bloated workflows or feature
                overload. In this article, I describe my minimal,
                focused, keyboard-centric workflow where I do my best
                work. In other words: I shill vim. <span
                class="date-info"><span
                class="date">2024-10-10</span><span
                class="updated">2025-07-13</span></span></p>
                </div>
                <h2 id="motivation">Motivation</h2>
                <p>The purpose of this article isn’t to persuade you to
                radically overhaul your development workflow overnight,
                nor is it a critique of “mainstream” editors and IDEs.
                My aim is to share my perspective and introduce you to
                an alternative (and in my opinion, more performant) set
                of tools that have worked well for me.</p>
                <p>In my view, there are two distinct domains of
                technical productivity:</p>
                <ol type="1">
                <li><p>Tools like Git and GitHub that provide essential
                workflow structure and safety nets when things go
                wrong.</p></li>
                <li><p>Tools and tweaks that directly speed up your
                development process and task completion rate. This is
                what I’ll talk about today.</p></li>
                </ol>
                <p>In order, I’ll discuss: the shell, command line
                tools, multiplexers, text editors, cases for automation,
                and development integration. We’ll end things with a
                mental model bringing it all together.</p>
                <h3
                id="what-were-not-covering-but-is-also-important">What
                We’re Not Covering (But Is Also Important)</h3>
                <p>This post talks about productivity tools and
                techniques which I feel will have the biggest impact for
                most users. I’m leaving out several foundational (but
                less productivity-focused) areas: hardware (keyboard
                layouts, system performance factors), operating system
                choices (FS architecture, process management, etc.),
                system admin and low-level configuration, and container
                tools (e.g., Docker).</p>
                <h2 id="the-shell">The Shell</h2>
                <p>Your shell is the foundation that every other tool
                builds upon, and frankly, most people are not taking
                full advantage of it.</p>
                <p>The default bash that ships with most systems is…
                fine. However, if you’re serious about command line
                productivity, you need to upgrade to something modern. I
                recommend <strong>zsh</strong> with <a
                href="https://ohmyz.sh/">Oh My Zsh</a>, or if you want
                something that works beautifully out of the box, try
                <strong>fish</strong>.</p>
                <p>Here are some things a modern shell has over
                bash:</p>
                <ul>
                <li><p>Intelligent autocompletion that actually
                understands context. Type <code>git</code> and hit
                tab—it knows you probably want <code>add</code>,
                <code>commit</code>, or <code>push</code>, not some
                random file in your directory.</p></li>
                <li><p>Syntax highlighting in real time. Mistype a
                command? It turns red before you even hit enter. No more
                “command not found”.</p></li>
                <li><p>History search that doesn’t suck. Hit
                <code>Ctrl+R</code> and type a few letters—kablam!
                There’s the command.</p></li>
                </ul>
                <p>But before we dive into configuration, can we talk
                about something that drives me absolutely insane?
                Please, for the love of all that is holy,
                <i><strong>resize your terminal window!</strong></i> I
                see people working in these tiny 80x24 windows like it’s
                1985. You have a 27-inch monitor and you’re squinting at
                12 lines of code at a time. Make your terminal bigger.
                Much bigger!</p>
                <p>Now, for the content of substance. First I had to
                configure the shell. That means creating aliases to
                eliminate the <em>friction</em><a href="#fn1"
                class="footnote-ref" id="fnref1"
                role="doc-noteref"><sup>1</sup></a> from my daily
                workflow:</p>
                <div class="sourceCode" id="cb1"><pre
                class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="bu">alias</span> v=<span class="st">&#39;nvim&#39;</span>                          <span class="co"># why type 4 letters when 1 will do?</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="bu">alias</span> c=<span class="st">&#39;clear&#39;</span>                         <span class="co"># (alternatively: CMD/CTRL-L)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="bu">alias</span> j=<span class="st">&#39;jobs&#39;</span>                          <span class="co"># see what&#39;s running in the background</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="bu">alias</span> ev=<span class="st">&#39;cd ~/.config/nvim/ &amp;&amp; nvim .&#39;</span> <span class="co"># jump to editor config</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="bu">alias</span> ...=<span class="st">&quot;cd ../..&quot;</span>                    <span class="co"># jump back two dirs</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="bu">alias</span> lg=<span class="st">&#39;lazygit&#39;</span>                      <span class="co"># git UI in the terminal</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="bu">alias</span> btop=<span class="st">&#39;btop&#39;</span>                       <span class="co"># better htop alternative</span></span></code></pre></div>
                <p>Beyond just saving keystrokes, I’m reducing the
                mental overhead of context switching. When I want to
                edit my Neovim config, I don’t want to remember the path
                and type out two commands. I want to type
                <code>ev</code> and be there.</p>
                <p>I learned to write functions for operations that are
                slightly too complex for aliases:</p>
                <div class="sourceCode" id="cb2"><pre
                class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">proj()</span> <span class="kw">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">cd</span> ~/dev/<span class="st">&quot;</span><span class="va">$1</span><span class="st">&quot;</span> <span class="kw">&amp;&amp;</span> <span class="ex">tmux</span> new-session <span class="at">-d</span> <span class="at">-s</span> <span class="st">&quot;</span><span class="va">$1</span><span class="st">&quot;</span> <span class="kw">&amp;&amp;</span> <span class="ex">tmux</span> attach <span class="at">-t</span> <span class="st">&quot;</span><span class="va">$1</span><span class="st">&quot;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">}</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co"># quick backup with timestamp</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="fu">backup()</span> <span class="kw">{</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">local</span> <span class="va">name</span><span class="op">=</span><span class="st">&quot;</span><span class="va">${1</span><span class="op">:-</span><span class="va">$(</span><span class="fu">basename</span> <span class="va">$(</span><span class="bu">pwd</span><span class="va">))}</span><span class="st">&quot;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">tar</span> <span class="at">-czf</span> ~/backups/<span class="st">&quot;</span><span class="va">$name</span><span class="st">&quot;</span>-<span class="va">$(</span><span class="fu">date</span> +%Y%m%d-%H%M<span class="va">)</span>.tar.gz .</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">echo</span> <span class="st">&quot;Backed up </span><span class="va">$name</span><span class="st"> to ~/backups/&quot;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="kw">}</span></span></code></pre></div>
                <p>Now <code>proj myapp</code> creates a new tmux
                session, navigates to my project directory, and drops me
                into a focused workspace. One command for a complete
                context switch.</p>
                <p>In general, the goal isn’t to memorize every flag and
                option. The goal is to configure my environment once<a
                href="#fn2" class="footnote-ref" id="fnref2"
                role="doc-noteref"><sup>2</sup></a>, correctly, so that
                the most efficient way to do something is also the most
                natural way.</p>
                <p><strong>DISCLAIMER:</strong> There is something worth
                mentioning. And it applies to all of the things I
                recommend in this post and beyond. I read all of this
                stuff, got excited, and tried to jam in a ton of
                features that looked cool and sounded useful. However,
                you must have balance! Add too many features and you
                drag out shell start up time. The best way to never have
                to worry about start up time is to take the features you
                absolutely need, and discard the rest. Just because
                something is flashy doesn’t mean you <em>need</em>
                it.</p>
                <aside id="footnotes"
                class="footnotes footnotes-end-of-section"
                role="doc-endnotes">
                <hr />
                <ol>
                <li id="fn1"><p>The objective is reducing the most
                common sources of friction in your everyday routine.
                Instead of trying to find a quicker way to do everything
                under the sun, reflect on your routines and make those
                processes swifter.<a href="#fnref1"
                class="footnote-back" role="doc-backlink">↩︎</a></p></li>
                <li id="fn2"><p>If you don’t want to set up your shell
                yourself, here is an <a
                href="https://github.com/jo%20tyGill/ezsh">elegant
                script</a>.<a href="#fnref2" class="footnote-back"
                role="doc-backlink">↩︎</a></p></li>
                </ol>
                </aside>
                <h2 id="essential-command-line-tools">Essential Command
                Line Tools</h2>
                <p>Now that my shell is properly configured (and my
                terminal is actually a usable size), it’s worth talking
                about the tools that do the heavy lifting in my
                day-to-day life.</p>
                <p>The Unix philosophy got a lot of things right: small
                programs that do one thing well, and do it really well.
                The core utilities (<code>grep</code>, <code>sed</code>,
                <code>awk</code>, <code>find</code>) have been around
                for decades because they work. I learned the classics
                first and I’m glad I did. Understanding that
                <code>grep</code> is for searching text,
                <code>find</code> is for locating files, and pipes
                (<code>|</code>) chain commands together forms the
                backbone of command line productivity:</p>
                <div class="sourceCode" id="cb3"><pre
                class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">find</span> . <span class="at">-name</span> <span class="st">&quot;*.js&quot;</span> <span class="kw">|</span> <span class="fu">grep</span> <span class="at">-v</span> node_modules <span class="kw">|</span> <span class="fu">head</span> <span class="at">-10</span></span></code></pre></div>
                <p>This finds JavaScript files, excludes node_modules,
                and shows the first 10 results. It’s composable,
                predictable, and works everywhere.</p>
                <p>Eventually, I upgraded to the modern alternatives.
                The new generation of command line tools takes the Unix
                philosophy and makes it faster, more user-friendly, and
                frankly, more pleasant to use:</p>
                <ul>
                <li><strong>ripgrep (<code>rg</code>)</strong> instead
                of <code>grep</code> — Faster with sane defaults</li>
                <li><strong>fd</strong> instead of <code>find</code> —
                Simple syntax</li>
                <li><strong>bat</strong> instead of <code>cat</code> —
                Syntax highlighting and line numbers built-in</li>
                <li><strong>eza</strong> instead of <code>ls</code> —
                Better formatting and git integration</li>
                <li><strong>dust</strong> instead of <code>du</code> —
                Visual disk usage</li>
                <li><strong>btop</strong> instead of <code>htop</code> —
                Beautiful, interactive process viewer</li>
                <li><strong>xh</strong> instead of <code>curl</code> —
                More intuitive HTTP client for API testing</li>
                <li><strong>jq</strong> for JSON processing — Powerful
                for parsing API responses and config files</li>
                </ul>
                <p>Here’s the same search with modern tools:</p>
                <div class="sourceCode" id="cb4"><pre
                class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ex">fd</span> <span class="st">&quot;\.js$&quot;</span> <span class="kw">|</span> <span class="ex">rg</span> <span class="at">-v</span> node_modules <span class="kw">|</span> <span class="fu">head</span> <span class="at">-10</span></span></code></pre></div>
                <p>Cleaner, faster, and the output actually looks
                good.</p>
                <p><strong>fzf</strong> (fuzzy finding) is fucking
                amazing. I installed it, configured it, and watched my
                productivity skyrocket. It turns any list into an
                interactive, searchable interface. Want to find a file?
                <code>Ctrl+T</code>. Want to search command history?
                <code>Ctrl+R</code>. Want to kill a process?
                <code>ps aux | fzf | awk '{print $2}' | xargs kill</code>.</p>
                <p>All of these are neat individual tools. But they’re
                also utilities which, when composed together, allow me
                to do literally anything. Mastering pipes, redirection,
                and command substitution means I can create powerful
                one-liners that solve complex problems in seconds.</p>
                <p>I didn’t try to learn everything at once—I tried that
                initially and it was overwhelming. I picked one modern
                tool, used it until it became muscle memory, then added
                the next one. The compound effect is what matters
                here.</p>
                <h2 id="terminal-multiplexers">Terminal
                Multiplexers</h2>
                <p>When I started spending a lot of time in my terminal,
                it quickly became apparent how cumbersome it could get.
                When web browsing, you can create new windows and
                swiftly <code>ALT-TAB</code> between them. Within a
                window, you can switch between tabs with
                <code>CMD/CTRL-0..9</code> You can bookmark and return
                to your workspace at will. There’s a parallel here—I
                could open multiple terminal windows, and that worked…
                sort of. But I still had to reopen everything with each
                new terminal instance.</p>
                <p>I found something much better. It does exactly what I
                want. It’s called <a
                href="https://tmuxcheatsheet.com/how-to-install-tmux/">tmux</a>,
                a terminal multiplexer.</p>
                <p>A terminal multiplexer is a program that
                transparently “sits between” your active terminal
                connection and spawned terminal sessions. With tmux, I
                can start a session, open new windows, and hotkey
                between them. I can detach and reattach to sessions at
                will. In other words, I can set a session aside and
                return to it later, and everything will be exactly how I
                left it.</p>
                <p>With a plugin, these sessions can even persist across
                system restarts.</p>
                <p>Tmux is incredibly useful, and if I’m doing
                <strong>any</strong> serious work in the terminal, it
                saves me a huge amount of time. I installed it and never
                looked back.</p>
                <p>I can create a new session with
                <code>tmux new -s session_name</code>, detach with
                <code>CTRL-B D</code>, and reattach with
                <code>tmux attach -t session_name</code>. Some other
                useful commands include:</p>
                <pre><code>tmux ls                             # list sessions
tmux kill-session -t session_name   # kill a session
tmux kill-server                    # kill the server
tmux a -t session_name              # attach to a session
tmux a                              # attach to the last session</code></pre>
                <h3 id="customization">Customization</h3>
                <p>When I start Tmux, the program looks for a .dotfile<a
                href="#fn3" class="footnote-ref" id="fnref3"
                role="doc-noteref"><sup>3</sup></a> at
                <code>~/.tmux.conf</code>. This plain-text file is where
                I can configure and “rice out”<a href="#fn4"
                class="footnote-ref" id="fnref4"
                role="doc-noteref"><sup>4</sup></a> my multiplexer. I
                began by adding a plugin manager, <a
                href="https://github.com/tmux-plugins/tpm">tpm</a>, and
                then used it to load a few plugins and a nice theme<a
                href="#fn5" class="footnote-ref" id="fnref5"
                role="doc-noteref"><sup>5</sup></a>.</p>
                <aside id="footnotes"
                class="footnotes footnotes-end-of-section"
                role="doc-endnotes">
                <hr />
                <ol start="3">
                <li id="fn3"><p>Many programs store their configuration
                files in plain text files. These are usually (but not
                always) in your <code>~</code> or
                <code>~/.config/~</code> directories. Dotfiles are
                configuration files for various programs. What sets them
                apart from regular files and directories is their
                prefix: a dot (<code>.</code>). Note: On Unix based
                systems, dotfiles are hidden by the OS by default.<a
                href="#fnref3" class="footnote-back"
                role="doc-backlink">↩︎</a></p></li>
                <li id="fn4"><p>Ricing is a process in which one
                customizes their OS or programs to improve the
                aesthetics or refine their workflow.<a href="#fnref4"
                class="footnote-back" role="doc-backlink">↩︎</a></p></li>
                <li id="fn5"><p>In earlier drafts, I recommended <a
                href="https://github.com/catppuccin/tmux">catppuccin</a>
                (mocha) or <a
                href="https://github.com/folke/tokyonight.nvim">tokyonight</a>
                by Folke; these days, I like a simpler, higher contrast
                theme like one of the built vim defaults, elflord.<a
                href="#fnref5" class="footnote-back"
                role="doc-backlink">↩︎</a></p></li>
                </ol>
                </aside>
                <h3 id="alternatively-wezterm-or-zellij">Alternatively:
                WezTerm or Zellij</h3>
                <p>If Tmux doesn’t tickle your fancy, try <a
                href="https://wezterm.org/index.html">WezTerm</a>, a
                cross-platform terminal emulator and multiplexer
                implemented in Rust. Its config is in Lua. This is what
                I use right now, and it’s very nice.</p>
                <p>There’s also <strong>Zellij</strong>, a newer
                multiplexer written in Rust that’s more
                beginner-friendly than tmux with floating panes and
                better defaults out of the box.</p>
                <p>But I still keep tmux skills sharp; when SSH’d into
                servers, tmux is often your only real option.</p>
                <h2 id="text-editors">Text Editors</h2>
                <p>Once I had my shell configured and my multiplexer
                managing my sessions, it was time to talk about the
                heart of my development workflow: my text editor.</p>
                <p>I’ve been using Vim for about three years. When we
                mention Vim, it’s usually in one of two contexts:
                <code>vim</code> (the program), or Vim Motions.</p>
                <p><strong>Vim Motions</strong> are the keybindings that
                allow you to move around the text. They are the most
                important part of Vim. I think everyone should use Vim
                Motions. They are extremely efficient. They’re available
                on all text editors and IDEs. <strong>Vim</strong>, by
                contrast, is a highly configurable, extensible text
                editor built to make creating and changing any kind of
                text very efficient.</p>
                <h3 id="vim-motions">Vim Motions</h3>
                <p>There is only one type of grammar in Vim: Vim
                Motions. It’s a language that allows you to move around
                the text.</p>
                <p>Here’s a quick reference of some common Vim
                Motions:</p>
                <table>
                <colgroup>
                <col style="width: 11%" />
                <col style="width: 10%" />
                <col style="width: 77%" />
                </colgroup>
                <thead>
                <tr class="header">
                <th>Category</th>
                <th>Command</th>
                <th>Description</th>
                </tr>
                </thead>
                <tbody>
                <tr class="odd">
                <td>motion</td>
                <td>h</td>
                <td>Left</td>
                </tr>
                <tr class="even">
                <td></td>
                <td>j</td>
                <td>Down</td>
                </tr>
                <tr class="odd">
                <td></td>
                <td>k</td>
                <td>Up</td>
                </tr>
                <tr class="even">
                <td></td>
                <td>l</td>
                <td>Right</td>
                </tr>
                <tr class="odd">
                <td></td>
                <td>w</td>
                <td>Move forward to the beginning of the next word</td>
                </tr>
                <tr class="even">
                <td></td>
                <td>}</td>
                <td>Jump to the next paragraph</td>
                </tr>
                <tr class="odd">
                <td></td>
                <td>$</td>
                <td>Go to the end of the line</td>
                </tr>
                <tr class="even">
                <td>operator</td>
                <td>y</td>
                <td>Yank text (copy)</td>
                </tr>
                <tr class="odd">
                <td></td>
                <td>d</td>
                <td>Delete text and save to register</td>
                </tr>
                <tr class="even">
                <td></td>
                <td>c</td>
                <td>Delete text, save to register, and start insert
                mode</td>
                </tr>
                </tbody>
                </table>
                <p>More generally, the syntax looks like:
                <code>[count] + &lt;operator&gt; + (motion)</code>. For
                example, <code>3dw</code> would delete three words.
                <code>2yy</code> would yank two lines. <code>c$</code>
                would delete to the end of the line and start insert
                mode. <code>dap</code> would delete a paragraph.
                <code>vi(y</code> would select within the nearest set of
                <code>{ }</code> and yank the contents. It’s wonderfully
                composable.</p>
                <p>Notice how, for some, the phonetic sound of the
                command matches the action. <code>d</code> for delete,
                <code>y</code> for yank, <code>c</code> for change. This
                is a mnemonic device to help remember the commands.
                Delete a paragraph? <code>dap</code>. Change a word?
                <code>caw</code>.</p>
                <h3 id="vim-the-program">Vim (The Program)</h3>
                <p>Vim, by contrast, is a highly configurable,
                extensible text editor in your terminal built to make
                creating and changing any kind of text very efficient.
                My friend <a href="https://scharenbroch.dev/">Lucas</a>
                rather aptly put:</p>
                <div class="quote-container">
                    <div class="quote-content">
                        <div class="quote-text">
                            Vim is the bliss of Ctrl C/V but applied to every facet of the editor.
                        </div>
                        <div class="quote-author">
                            Lucas Scharenbroch
                        </div>
                    </div>
                </div>
                <p>I think that’s a really good way to describe it. Vim
                recognizes and eliminates the vast majority of typing
                inefficiencies. The result is blazingly fast precision,
                and a workflow that feels like a dance.</p>
                <p>Lucas wrote a list of <a
                href="https://scharenbroch.dev/blog/vim-bindings/">every
                single Vim binding he knows</a>. It’s substantial, but I
                never learned them all at the same time. I started with
                a subset, and gradually expanded it.</p>
                <p>A contention I often receive is, “well, how do I
                debug in Vim?” I don’t. I use separate programs<a
                href="#fn6" class="footnote-ref" id="fnref6"
                role="doc-noteref"><sup>6</sup></a>. Each program is
                good at what it does. If I build a hodgepodge of
                functionality I end up with an IDE and that’s precisely
                what I’m trying to escape.</p>
                <p>I will concede, however, that Vim is not beginner
                friendly. There’s a learning curve. However, Vim is
                exceptionally user friendly<a href="#fn7"
                class="footnote-ref" id="fnref7"
                role="doc-noteref"><sup>7</sup></a>. Once I got the hang
                of things, and it clicked, it became really, really fun
                to use. Here’s <a
                href="https://scharenbroch.dev/blog/vim/">Lucas’
                argument</a> in favor of Vim.</p>
                <p>A lot of people recommend learning Vim Motions on
                your current editor first before switching to Vim full
                time. I didn’t do this, but it’s the path most people
                take. I’m a bit weird. I like to cold turkey and learn
                things from the ground up right away. But that’s a
                digression.</p>
                <aside id="footnotes"
                class="footnotes footnotes-end-of-section"
                role="doc-endnotes">
                <hr />
                <ol start="6">
                <li id="fn6"><p>In the case of debugging, one might opt
                for <code>gdb</code>, the browser, or the python
                debugger, etc.<a href="#fnref6" class="footnote-back"
                role="doc-backlink">↩︎</a></p></li>
                <li id="fn7"><p>I’m paraphrasing <a
                href="https://github.com/ThePrimeagen">ThePrimeagen</a>,
                a Neovim enjoyer and popular streamer.<a href="#fnref7"
                class="footnote-back" role="doc-backlink">↩︎</a></p></li>
                </ol>
                </aside>
                <h3 id="neovim">Neovim</h3>
                <p>Vim’s extensibility takes it to the next level.
                Enter: Neovim. Taken from the <a
                href="https://neovim.io/charter/">Neovim
                Charter</a>:</p>
                <blockquote>
                <p>Neovim is a refactor, and sometimes redactor, in the
                tradition of Vim. It is not a rewrite but a continuation
                and extension of Vim. Many clones and derivatives exist,
                some very clever—but none are Vim. Neovim is built for
                users who want the good parts of Vim, and more.</p>
                </blockquote>
                <p>Neovim’s component-like plugin structure allows me to
                drop in and take out functionality easily. I can bring
                in an <a
                href="https://github.com/neovim/nvim-lspconfig">LSP</a>,
                <a
                href="https://github.com/hrsh7th/nvim-cmp">completions</a>,
                <a
                href="https://github.com/L3MON4D3/LuaSnip">snippets</a>,
                <a href="https://github.com/tpope/vim-fugitive">git</a>,
                and <a
                href="https://github.com/nvim-neotest/neotest">testing</a>
                infrastructure. I can get new things too: <a
                href="https://github.com/nvim-treesitter">Treesitter</a>,
                <a
                href="https://github.com/nvim-telescope/telescope.nvim">Telescope</a>
                FZF (fuzzy finding), Scoped grep string searches, and <a
                href="https://github.com/ThePrimeagen/harpoon/tree/harpoon2">Harpoon</a>
                anchor points to jump around.</p>
                <p>What’s more, since I configure Neovim myself, I came
                away with a complete understanding of how each tool
                works, and how they interact with one another to create
                a complete ecosystem. By contrast, other editors and
                IDEs abstract this away.</p>
                <p>I know I just said a lot of words. The takeaway is
                this: With Neovim, I know exactly why everything works
                the way it does, and I can make it work exactly the way
                I want it to. The possibilities are, in fact,
                endless.</p>
                <p>Want functionality but there’s no plugin for it? My
                config is in Lua and everything in Lua is easy. I can
                make it, maintain it, push it to the Neovim community!
                The Neovim community is vibrant and full of passionate
                creators and maintainers who work hard to support the
                editor they love.</p>
                <h3
                id="alternative-editors-worth-mentioning">Alternative
                Editors Worth Mentioning</h3>
                <p><strong>tig</strong> — A terminal git browser that’s
                incredibly useful for exploring git history and staging
                changes interactively. I use this constantly instead of
                <code>git log</code>.</p>
                <p><strong>Helix</strong> — A post-modern text editor
                with vim-like keybindings but built-in LSP and
                tree-sitter support. The key difference is it uses
                selection → action instead of vim’s action → selection
                model. So instead of <code>d5w</code> (delete 5 words),
                you’d do <code>5wd</code> (select 5 words, then delete).
                There’s also <strong>Evil Helix</strong> which flips
                them back to vim’s way if you can’t handle the
                change.</p>
                <h2 id="workflow-automation">Workflow Automation</h2>
                <p>Now that I’ve covered the core tools—shell, command
                line utilities, multiplexers, and editors—it’s time to
                tie them all together into automated workflows that
                eliminate repetitive tasks I do every single day.</p>
                <p>Shell scripts became my friend. A rule I learned: if
                I find myself typing the same sequence of commands more
                than twice, I write a script. I don’t care if it’s just
                three lines—I write it anyway. Here’s one I use
                constantly:</p>
                <div class="sourceCode" id="cb6"><pre
                class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/bin/bash</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co"># backup.sh - my quick project backup</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="fu">tar</span> <span class="at">-czf</span> ~/backups/<span class="va">$(</span><span class="fu">basename</span> <span class="va">$(</span><span class="bu">pwd</span><span class="va">))</span>-<span class="va">$(</span><span class="fu">date</span> +%Y%m%d<span class="va">)</span>.tar.gz .</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">&quot;Backed up </span><span class="va">$(</span><span class="fu">basename</span> <span class="va">$(</span><span class="bu">pwd</span><span class="va">))</span><span class="st"> to ~/backups/&quot;</span></span></code></pre></div>
                <p>I threw it in my <code>PATH</code>, made it
                executable, and now <code>backup</code> creates a
                timestamped archive of my current project. Took 30
                seconds to write, saves hours over time.</p>
                <h3 id="making-scripts-global">Making Scripts
                Global</h3>
                <p>Before I go further, let me talk about where I put
                these scripts so they actually work from anywhere. I
                don’t want to type <code>./backup.sh</code> every time—I
                want to type <code>backup</code> and have it just
                work.</p>
                <p>I created a directory for my personal scripts:</p>
                <div class="sourceCode" id="cb7"><pre
                class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mkdir</span> <span class="at">-p</span> ~/.local/bin</span></code></pre></div>
                <p>I added this directory to my PATH by putting this in
                my shell config (<code>.zshrc</code>,
                <code>.bashrc</code>, etc.):</p>
                <div class="sourceCode" id="cb8"><pre
                class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="bu">export</span> <span class="va">PATH</span><span class="op">=</span><span class="st">&quot;</span><span class="va">$HOME</span><span class="st">/.local/bin:</span><span class="va">$PATH</span><span class="st">&quot;</span></span></code></pre></div>
                <p>Now, for any script I write, I make it executable and
                <a
                href="https://en.wikipedia.org/wiki/Symbolic_link">symlink</a>
                it to my bin directory:</p>
                <div class="sourceCode" id="cb9"><pre
                class="sourceCode bash"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">chmod</span> +x backup.sh</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="fu">ln</span> <span class="at">-s</span> /full/path/to/backup.sh ~/.local/bin/backup</span></code></pre></div>
                <p>Notice I dropped the <code>.sh</code> extension in
                the symlink. Global commands shouldn’t look like
                scripts. Instead, they should look like built-in
                commands. When I type <code>backup</code>, nobody needs
                to know it’s actually a shell script living somewhere
                else.</p>
                <p>This approach is cleaner than copying scripts around
                because I can edit the original file and the changes are
                immediately available everywhere. My scripts live in my
                projects or dotfiles repo, but they’re accessible from
                any directory.</p>
                <p>On that note, dotfiles management became
                non-negotiable for me: my shell config, my editor
                settings, my aliases—all of it is in version control.
                When I get a new machine or mess something up, I want to
                be back to my perfect setup in minutes, not hours.</p>
                <p>So, I created a dotfiles repository, used symlinks
                and a tool like <a
                href="https://www.gnu.org/software/stow/">GNU Stow</a>,
                and never lost my configuration again. My rule: if I
                spend more than 15 minutes customizing something, it
                goes in the dotfiles repo immediately.</p>
                <p>Project-specific automation helps too. I create
                <code>.envrc</code> files (using <a
                href="https://direnv.net/">direnv</a>) or simple shell
                scripts that set up my environment automatically:</p>
                <div class="sourceCode" id="cb10"><pre
                class="sourceCode bash"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># dev.sh - example project setup script</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="bu">export</span> <span class="va">DATABASE_URL</span><span class="op">=</span><span class="st">&quot;postgresql://localhost/myapp_dev&quot;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="bu">export</span> <span class="va">NODE_ENV</span><span class="op">=</span><span class="st">&quot;development&quot;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">[</span> <span class="ot">!</span> <span class="ot">-d</span> <span class="st">&quot;node_modules&quot;</span> <span class="bu">]</span><span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">echo</span> <span class="st">&quot;installing deps...&quot;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="ex">npm</span> install</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="cf">fi</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">&quot;env is prepared&quot;</span></span></code></pre></div>
                <p>In this example, every project now has its own
                <code>./dev.sh</code> that gets me from cold start to
                ready-to-code in one command.</p>
                <p>Again, we return to the idea of eliminating friction.
                I couldn’t possibly make scripts for every scenario (nor
                should I). Rather, I hasten those little context
                switches, those “wait, how do I do this again?” moments,
                those repetitive setup tasks. Eliminate them, and I find
                myself in flow state more often and frustrated less.</p>
                <h3
                id="package-management-and-environment-isolation">Package
                Management and Environment Isolation</h3>
                <p>Dotfiles management became my lifesaver after I got a
                new laptop and spent an entire weekend trying to
                recreate my perfect setup from memory. Never again. Now
                my shell config, my editor settings, my aliases—all of
                it lives in version control. When I mess something up or
                get a new machine, I’m back to my perfect setup in
                minutes, not hours.</p>
                <p>I created a dotfiles repository, learned to use
                symlinks and a tool like <a
                href="https://www.gnu.org/software/stow/">GNU Stow</a>,
                and never lost my configuration again. My rule now: if I
                spend more than 15 minutes customizing something, it
                goes in the dotfiles repo immediately. Future me always
                thanks past me for this.</p>
                <h2 id="development-integration">Development
                Integration</h2>
                <p>The final layer builds upon everything I’ve covered
                thus far, integrating my command line workflow with the
                broader development ecosystem: version control, build
                systems, testing frameworks, and deployment
                pipelines.</p>
                <p>This is where my terminal setup stopped being just a
                collection of tools and became something more. I
                probably don’t need all of these, but here are a few
                ideas:</p>
                <p>I configured aliases that match my actual
                workflow:</p>
                <div class="sourceCode" id="cb11"><pre
                class="sourceCode bash"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> config <span class="at">--global</span> alias.co checkout</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> config <span class="at">--global</span> alias.br branch</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> config <span class="at">--global</span> alias.st status</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> config <span class="at">--global</span> alias.unstage <span class="st">&#39;reset HEAD --&#39;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> config <span class="at">--global</span> alias.lg <span class="st">&quot;log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;</span></span></code></pre></div>
                <p>I created functions that handle entire workflows:</p>
                <div class="sourceCode" id="cb12"><pre
                class="sourceCode bash"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># quick commit with message</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="fu">qc()</span> <span class="kw">{</span> <span class="fu">git</span> add . <span class="kw">&amp;&amp;</span> <span class="fu">git</span> commit <span class="at">-m</span> <span class="st">&quot;</span><span class="va">$1</span><span class="st">&quot;</span> }</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co"># make and switch to new branch</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="fu">nb()</span> <span class="kw">{</span> <span class="fu">git</span> checkout <span class="at">-b</span> <span class="st">&quot;</span><span class="va">$1</span><span class="st">&quot;</span> }</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co"># push current branch and set upstream</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="fu">pushup()</span> <span class="kw">{</span> <span class="fu">git</span> push <span class="at">-u</span> origin <span class="va">$(</span><span class="fu">git</span> branch <span class="at">--show-current</span><span class="va">)</span> }</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="co"># clean merged branches</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="fu">gitclean()</span> <span class="kw">{</span> <span class="fu">git</span> branch <span class="at">--merged</span> <span class="kw">|</span> <span class="fu">grep</span> <span class="at">-v</span> <span class="st">&quot;\*\|main\|master&quot;</span> <span class="kw">|</span> <span class="fu">xargs</span> <span class="at">-n</span> 1 git branch <span class="at">-d</span> }</span></code></pre></div>
                <p>Now <code>qc "Fix login bug"</code> handles my entire
                commit process, and <code>nb feature/new-auth</code>
                creates and switches to a new branch in one command.</p>
                <p>I created project-agnostic scripts that handle the
                complexity of build tools:</p>
                <div class="sourceCode" id="cb13"><pre
                class="sourceCode bash"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># dev.sh - universal dev server</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">[</span> <span class="ot">-f</span> <span class="st">&quot;package.json&quot;</span> <span class="bu">]</span><span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="ex">npm</span> run dev <span class="dv">2</span><span class="op">&gt;</span>/dev/null <span class="kw">||</span> <span class="ex">npm</span> start</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="cf">elif</span> <span class="bu">[</span> <span class="ot">-f</span> <span class="st">&quot;Cargo.toml&quot;</span> <span class="bu">]</span><span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="ex">cargo</span> run</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="cf">elif</span> <span class="bu">[</span> <span class="ot">-f</span> <span class="st">&quot;Makefile&quot;</span> <span class="bu">]</span><span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">make</span> dev <span class="kw">||</span> <span class="fu">make</span> run</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="cf">elif</span> <span class="bu">[</span> <span class="ot">-f</span> <span class="st">&quot;docker-compose.yml&quot;</span> <span class="bu">]</span><span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    <span class="ex">docker-compose</span> up</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="cf">fi</span></span></code></pre></div>
                <p>I put this in my PATH, and now <code>dev</code>
                starts the right development server regardless of
                project type.</p>
                <p>The best test suite is the one I actually run:</p>
                <div class="sourceCode" id="cb14"><pre
                class="sourceCode bash"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># t.sh - a smart test runner</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">[</span> <span class="ot">-f</span> <span class="st">&quot;package.json&quot;</span> <span class="bu">]</span> <span class="kw">&amp;&amp;</span> <span class="fu">grep</span> <span class="at">-q</span> <span class="st">&quot;test&quot;</span> package.json<span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="ex">npm</span> test</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="cf">elif</span> <span class="bu">[</span> <span class="ot">-f</span> <span class="st">&quot;Cargo.toml&quot;</span> <span class="bu">]</span><span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="ex">cargo</span> test</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="cf">elif</span> <span class="bu">[</span> <span class="ot">-f</span> <span class="st">&quot;Makefile&quot;</span> <span class="bu">]</span> <span class="kw">&amp;&amp;</span> <span class="fu">grep</span> <span class="at">-q</span> <span class="st">&quot;test:&quot;</span> Makefile<span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">make</span> test</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="cf">elif</span> <span class="bu">[</span> <span class="ot">-f</span> <span class="st">&quot;pytest.ini&quot;</span> <span class="bu">]</span> <span class="kw">||</span> <span class="bu">[</span> <span class="ot">-f</span> <span class="st">&quot;pyproject.toml&quot;</span> <span class="bu">]</span><span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span class="ex">pytest</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="cf">fi</span></span></code></pre></div>
                <p>For Rust development, <strong>bacon</strong> is a
                game-changer—it runs in the background and shows compile
                errors and warnings in real-time as I type. No more
                constantly running <code>cargo check</code>. Combined
                with <strong>mprocs</strong> (a process runner that can
                manage multiple commands in panes), I can run
                <code>bacon</code>, <code>cargo run</code>, and maybe a
                database all in one organized view. It’s like having a
                custom IDE built from composable terminal tools.</p>
                <p>I make environment switching seamless with <a
                href="https://direnv.net/">direnv</a>, which
                automatically loads environment variables when I enter a
                project directory. Now every time I <code>cd</code> into
                a project, my environment is automatically
                configured.</p>
                <p>Importantly, these optimizations <em>compound</em>.
                When switching between projects is frictionless, when
                tests run automatically, when deployment is one command,
                I spend less time context switching. Every project feels
                familiar because the interface is consistent, even when
                the underlying technology stack is different.</p>
                <h2 id="mental-model">Mental Model</h2>
                <p>Now that I’ve walked through each component, here’s
                how I think about the complete picture of terminal
                tooling:</p>
                <p>Each layer builds upon the previous ones, creating a
                compound effect where mastering multiple aspects leads
                to exponential productivity gains rather than linear
                improvements. My shell provides the foundation, command
                line tools give me power, multiplexers organize my
                workspace, editors let me manipulate text efficiently,
                automation eliminates repetition, and development
                integration connects everything to my broader
                workflow.</p>
                <p>The key insight I learned: <strong>consistency trumps
                optimization</strong>. Having a universal interface
                across all projects (even if it’s not the absolute
                fastest for each individual stack) reduces cognitive
                load more than trying to optimize each workflow
                separately.</p>
                <h2 id="wrapping-up">Wrapping up</h2>
                <p>In exploring the minimalist, keyboard-centric
                workflow of command line tools and editors like Vim and
                Neovim, I’ve uncovered a significant truth about
                productivity in software development: simplicity and
                customization can profoundly enhance efficiency. By
                adopting tools such as Tmux and Vim, I’ve been able to
                create a highly personalized development environment.
                This environment not only streamlines tasks but also
                keeps the focus on coding, reducing distractions
                inherent in more complex IDEs. Embracing these tools
                involved a learning curve, but the long-term gains in
                speed, understanding, and adaptability made this
                investment worthwhile.</p>
                <p>For those willing to explore these command line
                utilities and text editors, the payoff is a more
                intuitive and efficient coding experience that aligns
                perfectly with the unique needs of each developer.</p>
                <p>And as always, remember: <strong><em>Life is like
                Vim: There are a lot of shortcuts and you should take
                them.</em></strong></p>
            </article>
        </div>
        <footer>
            <p class="footer-note">
                Enjoyed this? Check out <a href="/writing/">more posts</a> or <a href="/rss.xml">subscribe to RSS</a> for updates.
            </p>
            <p>© 2025 salm.dev</p>
        </footer>
    </body>
</html>
