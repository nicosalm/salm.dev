<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="icon" type="image/svg+xml" href="/assets/favicon.svg">
        <link rel="stylesheet" href="/styles/styles.css">
        <title>Winning Pokemon Showdown | salm.dev</title>
            </head>
    <body>
        <div>
            <header>
                <a href="/">home</a> / <a href="/writing/">writing</a>
            </header>
            <article>
                <h1 id="winning-pokemon-showdown">Winning Pokemon
                Showdown</h1>
                <div class="description">
                <p>We used game theory to find the mathematically
                optimal strategies in Pokémon Showdown battles. <span
                class="date-info"><span
                class="date">2025-05-11</span></span></p>
                </div>
                <h2 id="premise">Premise</h2>
                <p>In <a href="https://pokemonshowdown.com/">Pokémon
                Showdown</a>, you build a team of Pokémon and battle. In
                the 1v1 format, you bring three Pokémon and choose one
                for each battle. No switching allowed, so it’s pure
                strategic decision-making. A game has two phases:
                choosing your Pokémon (left) and battling (right):</p>
                <table style="margin: 0 auto; border-collapse: collapse;">
                <tr>
                <td style="padding: 10px; text-align: center;">
                <img src="./images/choosing-phase.jpeg" alt="choosing phase">
                </td>
                <td style="padding: 10px; text-align: center;">
                <img src="./images/battle-phase.jpeg" alt="battling phase">
                </td>
                </tr>
                </table>
                <p>When a player’s Pokemon’s
                <abbr title="Hitpoints">HP</abbr> reaches 0, the other
                player wins:</p>
                <p><img src="./images/outcome.gif" alt="Battle outcome GIF" style="width: 100%; max-width: 700px; display: block; margin: 0 auto;"></p>
                <h2 id="the-seven-pokemon-we-analyzed">The Seven Pokemon
                We Analyzed</h2>
                <p>For our project, my friends and I focused on seven of
                the most commonly used Pokémon in the January 2021
                Pokémon Showdown 1v1 leaderboard:</p>
                <img src="./images/top-7.jpeg" loading="lazy" alt="All seven Pokémon analyzed" style="width: 100%; max-width: 700px; display: block; margin: 0 auto;">
                <p style="text-align: center; font-style: italic; margin-top: 10px;">
                Primarina, Sylveon, Heatran, Urshifu, Rillaboom,
                Garchomp, and Zapdos
                </p>
                <p>Each Pokémon has its own unique typing, movesets, and
                stats that create diverse strategic matchups. For
                consistency, we used the most popular standard moveset
                for each Pokémon according to <a
                href="https://www.smogon.com/dex/ss/pokemon/">Smogon’s
                Strategy Dex</a>.</p>
                <h2 id="our-approach">Our Approach</h2>
                <p>Pokémon battles are <a
                href="https://en.wikipedia.org/wiki/Zero-sum_game">zero-sum
                games</a>: one player’s win is the other’s loss. Both
                players select moves simultaneously each turn, creating
                the exact type of strategic interaction game theory was
                built to solve. Crucially, zero-sum games are one of the
                few cases where we can efficiently compute Nash
                equilibria, unlike the general games that resist
                computation.</p>
                <p>We modeled these battles in two key stages:</p>
                <h2
                id="the-battling-phase-finding-optimal-move-strategies">The
                Battling Phase (Finding Optimal Move Strategies)</h2>
                <p>First, we needed to understand how each Pokémon
                matchup plays out when both players use optimal
                strategies. We built turn-based payoff matrices for each
                possible matchup, calculating expected damage and
                effects for every move combination using Showdown’s <a
                href="https://calc.pokemonshowdown.com/">Pokémon Damage
                Calculator</a>.</p>
                <img src="./images/single-turn-payoff.jpeg" loading="lazy" alt="Pokémon Move Damage Matrix" style="width: 100%; max-width: 600px; display: block; margin: 0 auto;">
                <p style="text-align: center; font-style: italic; margin-top: 10px;">
                This payoff matrix shows damage ranges between Garchomp
                and Sylveon’s moves
                </p>
                <p>Pokémon battles have random elements: move accuracy,
                critical hits, and damage ranges. We handled these with
                <a
                href="https://inst.eecs.berkeley.edu/~cs188/textbook/games/expectimax.html">expectimax
                trees</a> that calculate expected outcomes for each
                decision.</p>
                <img src="./images/example-game-tree.jpeg" loading="lazy" alt="Win Probabilities Matrix" style="width: 50%; max-width: 600px; display: block; margin: 0 auto;">
                <p style="text-align: center; font-style: italic; margin-top: 10px;">
                Example of a battle decision tree showing Hyper Beam
                outcomes between Primarina and Sylveon
                </p>
                <p>Some moves like <em>Sucker Punch</em> (which only
                works if the opponent uses an attacking move) create
                rock-paper-scissors style mind games that require <a
                href="https://en.wikipedia.org/wiki/Strategy_(game_theory)#Mixed_strategy">mixed
                strategy Nash equilibria</a>. When the payoff matrices
                got too complex, we turned to reinforcement learning to
                find strategies we’d never spot by hand.</p>
                <img src="./images/sucker-punch.jpeg" loading="lazy" alt="Sucker punch move" style="width: 100%; max-width: 300px; display: block; margin: 0 auto;">
                <p style="text-align: center; font-style: italic; margin-top: 10px;">
                Sucker Punch move
                </p>
                <h3 id="the-math-behind-nash-equilibrium">The Math
                Behind Nash Equilibrium</h3>
                <p>Pokemon battles are zero-sum games (one trainer’s win
                is the other’s loss), which means we can actually
                compute exact Nash equilibria efficiently using linear
                programming. As I explore in <a
                href="../nash-equilibria-hide-from-algorithms">Nash
                Equilibria Hide from Algorithms</a>, this tractability
                is special to zero-sum games:</p>
                <div class="sourceCode" id="cb1"><pre
                class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_nash_equilibrium(payoff_matrix):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Compute Nash equilibrium for zero-sum game via linear programming.</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">    payoff_matrix[i,j] = payoff when P1 plays i, P2 plays j</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns: (p1_strategy, p2_strategy, game_value)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    num_rows, num_cols <span class="op">=</span> payoff_matrix.shape</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set up Player 1&#39;s LP</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> np.zeros(num_rows <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    c[<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="op">-</span><span class="dv">1</span>  <span class="co"># maximize game value v</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Expected payoff &gt;= v against any P2 strategy</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    A_ub <span class="op">=</span> np.zeros((num_cols, num_rows <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(num_cols):</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        A_ub[j, :<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="op">-</span>payoff_matrix[:, j]</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        A_ub[j, <span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    b_ub <span class="op">=</span> np.zeros(num_cols)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Probabilities sum to 1</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    A_eq <span class="op">=</span> np.zeros((<span class="dv">1</span>, num_rows <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    A_eq[<span class="dv">0</span>, :<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    b_eq <span class="op">=</span> np.ones(<span class="dv">1</span>)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    bounds <span class="op">=</span> [(<span class="dv">0</span>, <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(num_rows)] <span class="op">+</span> [(<span class="va">None</span>, <span class="va">None</span>)]</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Solve</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    res1 <span class="op">=</span> linprog(c, A_ub<span class="op">=</span>A_ub, b_ub<span class="op">=</span>b_ub, A_eq<span class="op">=</span>A_eq, b_eq<span class="op">=</span>b_eq,</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>                   bounds<span class="op">=</span>bounds, method<span class="op">=</span><span class="st">&#39;highs&#39;</span>)</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    p1_strategy <span class="op">=</span> res1.x[:<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> <span class="op">-</span>res1.fun</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Player 2&#39;s LP omitted...</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> p1_strategy, p2_strategy, v</span></code></pre></div>
                <p>The code above computes the mathematically optimal
                mixed strategy for each player. In the <em>Rillaboom
                vs. Urshifu</em> matchup, the math confirmed what top
                players already knew: Urshifu should mix <em>Sucker
                Punch</em> and <em>Wicked Blow</em> exactly 50/50 in
                late turns, while Rillaboom adapts between <em>Swords
                Dance</em> and <em>Grassy Glide</em> based on the
                situation.</p>
                <h2
                id="the-choosing-phase-team-selection-strategies">The
                Choosing Phase (Team Selection Strategies)</h2>
                <p>With optimal move strategies worked out for
                individual battles, we turned to the team selection
                meta-game. After simulating over 1 million battles for
                each possible matchup, we built a payoff matrix of win
                probabilities:</p>
                <img src="./images/payoff-matrix-full.jpeg" loading="lazy" alt="Win Probabilities Matrix" style="width: 100%; max-width: 600px; display: block; margin: 0 auto;">
                <p style="text-align: center; font-style: italic; margin-top: 10px;">
                Matchup win probability matrix
                </p>
                <p>Using this matrix, we could then solve for the
                optimal team selection strategies.</p>
                <h3 id="analyzing-team-performance">Analyzing Team
                Performance</h3>
                <p>We analyzed all 35 possible team combinations using
                our 7 selected Pokémon, evaluating a total of 595 unique
                matchups. Here’s how we calculated the average win
                rates:</p>
                <div class="sourceCode" id="cb2"><pre
                class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> analyze_matchup(team_a, team_b, win_probabilities):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Calculate team_a&#39;s win probability against team_b&quot;&quot;&quot;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    payoff_matrix <span class="op">=</span> create_payoff_matrix(team_a, team_b, win_probabilities)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    _, _, game_value <span class="op">=</span> compute_nash_equilibrium(payoff_matrix)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> game_value</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate win rates</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>team_results <span class="op">=</span> {}</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> team <span class="kw">in</span> all_team_combinations:</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    total_win_rate <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    total_matchups <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> opponent_team <span class="kw">in</span> all_team_combinations:</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> team <span class="op">!=</span> opponent_team:</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>            win_rate <span class="op">=</span> analyze_matchup(team, opponent_team, win_probabilities)</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>            total_win_rate <span class="op">+=</span> win_rate</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>            total_matchups <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    team_results[team] <span class="op">=</span> total_win_rate <span class="op">/</span> total_matchups</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Sort teams by average win rate</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>best_teams <span class="op">=</span> <span class="bu">sorted</span>(team_results.items(), key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>], reverse<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
                <img src="./images/team-performance-ranking.jpeg" loading="lazy" alt="Win Probabilities Matrix" style="width: 100%; max-width: 600px; display: block; margin: 0 auto;">
                <p style="text-align: center; font-style: italic; margin-top: 10px;">
                Team performance ranking based on average win rates
                </p>
                <h2 id="key-findings">Key Findings</h2>
                <p>The strongest team turned out to be Heatran, Sylveon,
                and Zapdos with a 62.4% average win rate across all
                matchups. Garchomp, Heatran, and Urshifu together
                struggled at just 29.7%. Sylveon was the MVP,
                maintaining a 55.3% win rate across all team
                compositions.</p>
                <img src="./images/avg-winrate.jpeg" loading="lazy" alt="Win Probabilities Matrix" style="width: 100%; max-width: 500px; display: block; margin: 0 auto;">
                <p style="text-align: center; font-style: italic; margin-top: 10px;">
                Best and worst performing Pokémon based on Nash
                equilibrium calculations
                </p>
                <p>Teams with Sylveon and Zapdos consistently won in our
                simulations. Pairing Heatran with Urshifu was a recipe
                for disaster.</p>
                <h2 id="cool-matchup-examples">Cool Matchup
                Examples</h2>
                <h3 id="heatran-vs.-garchomp">Heatran vs. Garchomp</h3>
                <p><em>Heatran vs. Garchomp</em> was one of the simpler
                matchups. Despite Garchomp’s fearsome reputation,
                Heatran wins 81.7% of the time when both players play
                optimally.</p>
                <img src="./images/matchup-heatran-garchomp.jpeg" loading="lazy" alt="Heatran vs Garchomp" style="width: 100%; max-width: 500px; display: block; margin: 0 auto;">
                <p style="text-align: center; font-style: italic; margin-top: 10px;">
                Battle setup and outcome for Heatran vs. Garchomp
                </p>
                <p>Heatran should open with <em>Will-O-Wisp</em> to burn
                and halve Garchomp’s attack, then spam <em>Dragon
                Pulse</em>. Garchomp’s best bet is <em>Stone Edge</em>
                despite its 80% accuracy.</p>
                <h3 id="rillaboom-vs.-urshifu">Rillaboom
                vs. Urshifu</h3>
                <p><em>Rillaboom vs. Urshifu</em> is where the mind
                games get real. <em>Sucker Punch</em> only works against
                attacking moves, so neither Pokémon has a dominant
                strategy.</p>
                <img src="./images/payoff-rillaboom-urshifu.jpeg" loading="lazy" alt="Rillaboom vs Urshifu" style="width: 100%; max-width: 500px; display: block; margin: 0 auto;">
                <p style="text-align: center; font-style: italic; margin-top: 10px;">
                Payoff matrix for Rillaboom vs. Urshifu involving the
                move Sucker Punch
                </p>
                <p>The math says Urshifu should mix Sucker Punch and
                Wicked Blow 50/50 after turn 2, while Rillaboom adapts
                to the situation:</p>
                <img src="./images/matchup-rillaboom-urshifu.jpeg" loading="lazy" alt="Rillaboom vs Urshifu" style="width: 100%; max-width: 500px; display: block; margin: 0 auto;">
                <p style="text-align: center; font-style: italic; margin-top: 10px;">
                Battle setup and outcome for Rillaboom vs. Urshifu
                </p>
                <p>Even with perfect play from both sides, Rillaboom
                wins 69.5% of the time.</p>
                <h2 id="an-interesting-convergence">An Interesting
                Convergence</h2>
                <p>Jake, our Pokémon expert (with over 5000 hours?!),
                predicted almost identical strategies to our
                mathematical model.</p>
                <h2 id="nash-equilibria-in-team-selection">Nash
                Equilibria in Team Selection</h2>
                <p>Some team matchups resulted in pure Nash equilibria
                with dominant strategies:</p>
                <img src="./images/pne.jpeg" alt="Pure Nash Equilibrium" loading="lazy" style="width: 100%; max-width: 500px; display: block; margin: 0 auto;">
                <p style="text-align: center; font-style: italic; margin-top: 10px;">
                Example of a pure Nash equilibrium in team selection
                </p>
                <p>While others required mixed strategies, creating a
                Rock-Paper-Scissors dynamic:</p>
                <img src="./images/mixed.jpeg" loading="lazy" alt="Mixed Nash Equilibrium" style="width: 100%; max-width: 1000px; display: block; margin: 0 auto;">
                <p style="text-align: center; font-style: italic; margin-top: 10px;">
                Example of a mixed Nash equilibrium in team selection
                </p>
                <p>When our best team (Heatran, Sylveon, Zapdos) faced
                our worst team (Garchomp, Heatran, Urshifu), the best
                team only won 50.5% of the time.<a href="#fn1"
                class="footnote-ref" id="fnref1"
                role="doc-noteref"><sup>1</sup></a></p>
                <aside id="footnotes"
                class="footnotes footnotes-end-of-section"
                role="doc-endnotes">
                <hr />
                <ol>
                <li id="fn1"><p>This is rock-paper-scissors at the team
                level. Just because Team A beats Team B and Team B beats
                Team C doesn’t necessarily mean Team A beats Team C.
                This creates a complex competitive landscape where no
                single team dominates everything.<a href="#fnref1"
                class="footnote-back" role="doc-backlink">↩︎</a></p></li>
                </ol>
                </aside>
                <h2 id="challenges-limitations">Challenges &amp;
                Limitations</h2>
                <p>Our biggest challenge was Pokémon’s randomness. With
                16 possible damage rolls per move and multi-turn
                battles, we needed tons of simulations rather than pure
                expectimax trees to get reliable win rates.<a
                href="#fn2" class="footnote-ref" id="fnref2"
                role="doc-noteref"><sup>2</sup></a></p>
                <p>At first, Rillaboom was broken. It had no bad
                matchups (worst case: 50% win rate against itself). We
                added Zapdos and Garchomp to create actual
                counterplay.</p>
                <p>One limitation was our decision to use fixed
                movesets. In competitive play, moveset variation is
                crucial for creating unpredictability and gaining an
                edge.<a href="#fn3" class="footnote-ref" id="fnref3"
                role="doc-noteref"><sup>3</sup></a></p>
                <aside id="footnotes"
                class="footnotes footnotes-end-of-section"
                role="doc-endnotes">
                <hr />
                <ol start="2">
                <li id="fn2"><p>Our final solution involved running over
                1 million simulations for each matchup to accurately
                account for all possible random outcomes. This was
                computationally intensive but necessary to get
                statistically significant results.<a href="#fnref2"
                class="footnote-back" role="doc-backlink">↩︎</a></p></li>
                <li id="fn3"><p>While we used the standard Smogon
                Strategy Dex movesets for consistency, competitive
                players often use surprise movesets to gain an edge.<a
                href="#fnref3" class="footnote-back"
                role="doc-backlink">↩︎</a></p></li>
                </ol>
                </aside>
                <h2 id="conclusion-future-work">Conclusion &amp; Future
                Work</h2>
                <p>We successfully found optimal Pokémon strategies
                using game theory.</p>
                <p>The computational complexity explodes as we add
                Pokémon. With just 7 Pokémon, we evaluated 595 unique
                matchups. With 50 Pokémon, we’d need to analyze over
                230,000 team combinations and millions of matchups. For
                n Pokémon, we’d need approximately O(n² + (n choose 3)²)
                matchups. Pokémon battles hit a sweet spot where optimal
                strategies exist but are hard to find due to the massive
                state space. That said, it’s possible! (We might just
                have to rewrite our Python in Rust…)</p>
                <p>Looking ahead, we’d like to expand to the top 50
                Pokémon in the current meta. We’d need to account for
                unknown movesets and better handle the randomness.
                Eventually we want to tackle 6v6 with switching. That’s
                9 choices per turn instead of 4.</p>
                <p>Our <a
                href="https://github.com/nicosalm/pokemon-expectimax/blob/main/report/CS839_FinalReport_PokemonBattles.pdf">paper</a>
                and <a
                href="https://github.com/nicosalm/pokemon-expectimax/tree/main">code</a>
                are available on GitHub if you’d like to explore our
                methods or build upon our work. Special thanks to
                Professor Manolis Vlatakis for being an encouraging
                mentor through this process! This project spawned out of
                his graduate class at UW-Madison: Game Theory,
                Optimization, and Learning (in Spring ’25).</p>
            </article>
<div class="the-end">~ fin ~</div><div class="similar-writing"><div class="post-navigation"><div class="nav-prev">← Prev: <a href="/writing/dungeons-dragons-and-development/">Dungeons, Dragons & Development</a></div><div class="nav-next">Next: <a href="/writing/create-dont-consume/">Create, Don't Consume</a> →</div></div><div class="related-posts"><h4>Related by Tag:</h4><ul><li><small><a href="/writing/nash-equilibria-hide-from-algorithms/">Nash Equilibria Hide from Algorithms</a></small></li></ul></div></div>
        </div>
        <footer>
            <p>© 2025 salm.dev</p>
        </footer>
    </body>
</html>
